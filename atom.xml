<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IFchanged</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ifchanged.io/"/>
  <updated>2017-09-09T09:14:58.000Z</updated>
  <id>http://ifchanged.io/</id>
  
  <author>
    <name>zeroten</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes笔记</title>
    <link href="http://ifchanged.io/2017/Kubernetes%E7%AC%94%E8%AE%B0/"/>
    <id>http://ifchanged.io/2017/Kubernetes笔记/</id>
    <published>2017-09-08T16:33:43.000Z</published>
    <updated>2017-09-09T09:14:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Kubernetes一个用于容器集群的自动化部署、扩容以及运维的开源平台。</p>
<h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><ul>
<li>master：主节点，负责k8s调度，不应部署容器</li>
<li>node：master之外的主机节点</li>
<li>pod：一组容器的集合，在一个pod只部署一个容器时，可基本等价于容器实例</li>
<li>deployment：一个容器、编排部署集合</li>
<li>service：一个服务，简单理解deployment通过service暴露在网络中</li>
</ul>
<p>所以，用deployment管理一组pod，用service暴露deployment。</p>
<ul>
<li><p>Pod: 若干 container 组成的一个功能单元，共享相同的 IP / Namesapce / Volume</p>
<a id="more"></a> 
<h3 id="1-2-基本架构"><a href="#1-2-基本架构" class="headerlink" title="1.2 基本架构"></a>1.2 基本架构</h3></li>
<li><p>Single Master: </p>
<ul>
<li>kube-apiserver - 响应 REST 请求，更新 etcd 信息</li>
<li>kube-scheduler - Pods 调度</li>
<li>kube-controller-manager - 所有其它控制功能</li>
</ul>
</li>
<li>Nodes: <ul>
<li>kube-proxy - 网络代理和负载均衡器</li>
<li>kubelet - 与 master 交互，管理 Pod</li>
</ul>
</li>
</ul>
<p>Internet –&gt; kube-proxy –&gt; Pods</p>
<p>注：1.2版之前是由运行在 userspace 的 kube-proxy 分发请求，1.2 版 kube-proxy 监视服务变化，生成相应 iptables rules</p>
<h3 id="1-3-部署模型"><a href="#1-3-部署模型" class="headerlink" title="1.3 部署模型"></a>1.3 部署模型</h3><ul>
<li>Deployment/Replication controller - Pod 池，确保一个 Pod 有一定份数运行，可用作负载均衡和水平扩展</li>
<li>Service - 定义了一组 Pods 的逻辑集合和访问这个集合的策略，提供一个 Micro Service</li>
<li>Endpoints - 一个 API，更新 Service 中的 Pods 集合</li>
</ul>
<h2 id="2-k8s技术介绍"><a href="#2-k8s技术介绍" class="headerlink" title="2. k8s技术介绍"></a>2. k8s技术介绍</h2><h3 id="2-1-网络"><a href="#2-1-网络" class="headerlink" title="2.1 网络"></a>2.1 网络</h3><p>使用flannel组件建立容器间网络，也是运维管理维护最麻烦的地方，因此：</p>
<ul>
<li>有三个网络，只需要运维了解，业务开发时不需要关心：<ul>
<li>Cluster Network：虚拟局域网，pod所处的实际网络，pod获得Cluster IP。Cluster Network内部互通，内部pod可以访问公网、物理局域网</li>
<li>物理局域网：外部主机所处的物流局域网</li>
<li>公网</li>
</ul>
</li>
<li>容器继承Node的DNS配置，不继承hosts</li>
<li>pod访问外部时，通过所在Node的网络</li>
<li>只能在Master通过NodePort，把service的端口和物理机连接，把service暴露给公网，这就造成Master的网络压力较大</li>
</ul>
<h3 id="2-3-服务发现"><a href="#2-3-服务发现" class="headerlink" title="2.3 服务发现"></a>2.3 服务发现</h3><p>k8s提供两种发现服务的方式，环境变量和DNS。由于数据库类资源通常使用外部资源，所以有用的是DNS自动给每个service自动注册name，由此可大大简化api-gateway的配置管理工作。</p>
<h4 id="2-3-1-api-gateway"><a href="#2-3-1-api-gateway" class="headerlink" title="2.3.1 api-gateway"></a>2.3.1 api-gateway</h4><p>由于当前网络模式不支持使用宿主机的hosts，且k8s有访问发现机制，所以，</p>
<ol>
<li>gateway地址使用<strong>api-gateway</strong>，免去自建DNS开销。</li>
<li>app地址使用k8s提供的Internal endpoints，即app:port形式，统一使用80端口，则简化为app</li>
<li>app统一使用HTTP协议提供服务<br>例子：<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">location</span> /xxx/ &#123;</div><div class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/xxx/(.*)</span> /<span class="variable">$1</span> <span class="literal">break</span>;</div><div class="line">    <span class="attribute">proxy_pass</span> xxx;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>需要说明的是，api-gateway和app都应该存在于cluster network内。对于cluster network外的api service，Nginx规则按照老形式配置IP:Port形式；对于cluster network外的需要访问api-gateway的app，则访问外部Nginx，外部Nginx通过NodePort反向代理把请求发送给内部Nginx。</p>
<h3 id="2-4-负载均衡"><a href="#2-4-负载均衡" class="headerlink" title="2.4 负载均衡"></a>2.4 负载均衡</h3><p>请求是首先访问service，然后service根据设置的策略访问pod。简单负载均衡模式和负载均衡器模式可以无缝切换。</p>
<h4 id="2-4-1-简单负载均衡"><a href="#2-4-1-简单负载均衡" class="headerlink" title="2.4.1 简单负载均衡"></a>2.4.1 简单负载均衡</h4><p>在service不使用LoadBalancer模式时，，service以<strong>随机</strong>的方式选择pod。</p>
<p>注：service的实现基于kube-proxy，kube-proxy有两种模式。<strong>userspace</strong>会<strong>循环</strong>选择pod，<strong>iptables</strong>模式会<strong>随机</strong>选择pod，<strong>iptables</strong>是默认模式且性能更好。</p>
<h4 id="2-4-2-使用阿里云SLB负载均衡"><a href="#2-4-2-使用阿里云SLB负载均衡" class="headerlink" title="2.4.2 使用阿里云SLB负载均衡"></a>2.4.2 使用阿里云SLB负载均衡</h4><p>可以直接使用阿里云负载均衡服务<a href="https://intl.aliyun.com/zh/product/server-load-balancer" target="_blank" rel="external">https://intl.aliyun.com/zh/product/server-load-balancer</a>。<code>kubectl expose deployment nginx --port=80 --target-port=80 --type=LoadBalancer</code> 即可。具</p>
<h3 id="2-5-容器调度"><a href="#2-5-容器调度" class="headerlink" title="2.5 容器调度"></a>2.5 容器调度</h3><h4 id="2-5-1-扩容和缩容"><a href="#2-5-1-扩容和缩容" class="headerlink" title="2.5.1 扩容和缩容"></a>2.5.1 扩容和缩容</h4><p>只需要修改deployment配置文件中的spec.replicas参数，k8s会立刻执行调度。</p>
<h4 id="2-5-2-自动调度"><a href="#2-5-2-自动调度" class="headerlink" title="2.5.2 自动调度"></a>2.5.2 自动调度</h4><ul>
<li>k8s会根据Node负载情况分配pod</li>
<li>当有Node不可用时，k8s会自动把pod调度到可用Node</li>
<li>当有docker 容器被关闭时，k8s会根据deploy根据spec.replicas，保证有正确数量的容器在运行</li>
</ul>
<h4 id="2-5-3-pod健康检查"><a href="#2-5-3-pod健康检查" class="headerlink" title="2.5.3 pod健康检查"></a>2.5.3 pod健康检查</h4><p>k8s提供探针对容器进行检测，可以后续开发</p>
<h4 id="2-5-4-自动扩容"><a href="#2-5-4-自动扩容" class="headerlink" title="2.5.4 自动扩容"></a>2.5.4 自动扩容</h4><p>K8s提供<strong>HorizontalPodAutoscaler</strong>实现自动扩容，即根据性能指标自动增加pod的数量，但目前性能指标只支持CPU使用率。</p>
<h2 id="3-k8s的使用"><a href="#3-k8s的使用" class="headerlink" title="3. k8s的使用"></a>3. k8s的使用</h2><h3 id="3-1-更新容器"><a href="#3-1-更新容器" class="headerlink" title="3.1 更新容器"></a>3.1 更新容器</h3><p>可以使用Jenkins调度api或者kubectl</p>
<h4 id="3-1-1-滚动升级"><a href="#3-1-1-滚动升级" class="headerlink" title="3.1.1 滚动升级"></a>3.1.1 滚动升级</h4><p>k8s支持滚动升级，升级过程中，pod逐个替换，直到替换完成，在此过程中旧Pod依然会被使用。可设置minReadySeconds表示启动容器后等待程序启动的时间。</p>
<p>只有更新PodTemplateSpec时才会触发滚动升级，如果镜像使用latest tag，则需要使用<code>kubectl patch deployment &lt;name&gt; -p &quot;{\&quot;spec\&quot;:{\&quot;template\&quot;:{\&quot;metadata\&quot;:{\&quot;labels\&quot;:{\&quot;date\&quot;‌​:\&quot;$(date +%s)\&quot;}}}}}&quot;</code>。</p>
<h4 id="3-1-2-配置更新"><a href="#3-1-2-配置更新" class="headerlink" title="3.1.2 配置更新"></a>3.1.2 配置更新</h4><p>如果需要修改环境变量、pod数量等，可以更新配置文件然后使用<code>kubectl apply -f &lt;filename&gt;</code>。</p>
<h3 id="3-2-配置文件管理"><a href="#3-2-配置文件管理" class="headerlink" title="3.2 配置文件管理"></a>3.2 配置文件管理</h3><h4 id="3-2-1-deployment和service配置文件管理"><a href="#3-2-1-deployment和service配置文件管理" class="headerlink" title="3.2.1 deployment和service配置文件管理"></a>3.2.1 deployment和service配置文件管理</h4><p>一个应用接入k8s只需要编写一个配置文件，包含deployment和service两项配置，如：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="attr">apiVersion:</span> extensions/v1beta1</div><div class="line"><span class="attr">kind:</span> Deployment</div><div class="line"><span class="attr">metadata:</span></div><div class="line"><span class="attr">  name:</span> simples</div><div class="line"><span class="attr">spec:</span></div><div class="line"><span class="attr">  replicas:</span> <span class="number">3</span></div><div class="line"><span class="attr">  template:</span></div><div class="line"><span class="attr">    metadata:</span></div><div class="line"><span class="attr">      labels:</span></div><div class="line"><span class="attr">        app:</span> simples</div><div class="line"><span class="attr">    spec:</span></div><div class="line"><span class="attr">      containers:</span></div><div class="line"><span class="attr">      - name:</span> master</div><div class="line"><span class="attr">        image:</span> imgage.xxx.com/test/simples:latest  <span class="comment"># or just image: redis</span></div><div class="line"><span class="attr">        env:</span></div><div class="line"><span class="attr">        - name:</span> ENV_VAR</div><div class="line"><span class="attr">          value:</span> <span class="string">"10086"</span></div><div class="line"><span class="attr">        ports:</span></div><div class="line"><span class="attr">        - containerPort:</span> <span class="number">9999</span></div><div class="line"><span class="attr">      imagePullSecrets:</span></div><div class="line"><span class="attr">      - name:</span> keyyy</div><div class="line"></div><div class="line">      </div><div class="line"><span class="attr">apiVersion:</span> v1</div><div class="line"><span class="attr">kind:</span> Service</div><div class="line"><span class="attr">metadata:</span></div><div class="line"><span class="attr">  name:</span> aaa</div><div class="line"><span class="attr">  labels:</span></div><div class="line"><span class="attr">    app:</span> aaa</div><div class="line"><span class="attr">spec:</span></div><div class="line"><span class="attr">  ports:</span></div><div class="line">    <span class="comment"># the port that this service should serve on</span></div><div class="line"><span class="attr">  - port:</span> <span class="number">80</span></div><div class="line"><span class="attr">  selector:</span></div><div class="line"><span class="attr">    app:</span> aaa</div></pre></td></tr></table></figure>
<p>每个应用自定义的内容只有环境变量和镜像地址。所有配置使用配置文件统一管理，配置文件使用git管理。</p>
<h4 id="3-2-2-环境变量管理"><a href="#3-2-2-环境变量管理" class="headerlink" title="3.2.2 环境变量管理"></a>3.2.2 环境变量管理</h4><p>通用变量，如数据库配置、mns配置放入configMap，app引用configMap的值。各app自己的变量写入自己的配置文件。</p>
<h3 id="3-3-dashboard"><a href="#3-3-dashboard" class="headerlink" title="3.3 dashboard"></a>3.3 dashboard</h3><p>官方web UI项目：<a href="https://github.com/kubernetes/dashboard" target="_blank" rel="external">https://github.com/kubernetes/dashboard</a></p>
<p>dashboard可以查看相关信息，以及容器日志，不建议在dashboard编辑配置，应该使用配置文件。</p>
<h3 id="3-4-容器管理"><a href="#3-4-容器管理" class="headerlink" title="3.4 容器管理"></a>3.4 容器管理</h3><p>可以使用<code>kubectl</code>命令类似<code>docker</code>命令地关闭、重启、进入容器等。</p>
<h4 id="3-3-1-账户登录"><a href="#3-3-1-账户登录" class="headerlink" title="3.3.1 账户登录"></a>3.3.1 账户登录</h4><p>dashboard 不提供用户登录系统。</p>
<p>使用Nginx的Basic HTTP authentication功能为dashboard提供登录保护，参见<a href="http://nginx.org/en/docs/http/ngx_http_auth_basic_module.html" target="_blank" rel="external">http://nginx.org/en/docs/http/ngx_http_auth_basic_module.html</a>和<a href="http://www.ttlsa.com/nginx/nginx-basic-http-authentication/" target="_blank" rel="external">http://www.ttlsa.com/nginx/nginx-basic-http-authentication/</a>，可以为不同用户设置不同密码。</p>
<h4 id="3-3-2-权限管理"><a href="#3-3-2-权限管理" class="headerlink" title="3.3.2 权限管理"></a>3.3.2 权限管理</h4><p>暂无好方案实现账户权限管理</p>
<h2 id="4-k8s接入备忘录"><a href="#4-k8s接入备忘录" class="headerlink" title="4. k8s接入备忘录"></a>4. k8s接入备忘录</h2><h3 id="api-gateway改造"><a href="#api-gateway改造" class="headerlink" title="api-gateway改造"></a>api-gateway改造</h3><ol>
<li>api service有uwsgi协议改为http协议</li>
<li>api-gateway地址可直接使用service的地址</li>
<li>api service统一使用80端口</li>
</ol>
<h3 id="环境变量改造"><a href="#环境变量改造" class="headerlink" title="环境变量改造"></a>环境变量改造</h3><p>让和环境有关的变量都使用环境变量管理，包括：</p>
<ul>
<li>MySQL数据库<ul>
<li>host</li>
<li>密码</li>
</ul>
</li>
<li>redis地址</li>
<li>Mongo地址</li>
<li>MNS配置</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="静态资源管理"><a href="#静态资源管理" class="headerlink" title="静态资源管理"></a>静态资源管理</h3><p>静态资源可以直接用Nginx挂在物理机上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>因为解决了宿主机端口冲突问题，方便的环境变量管理，可以做到一键创建环境，极大的减少了运维管理成本。</p>
<p>注：kubernetes更新十分迅速，部分信息可能失效，本文根据kubernetes 1.7探索所得。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;p&gt;Kubernetes一个用于容器集群的自动化部署、扩容以及运维的开源平台。&lt;/p&gt;
&lt;h3 id=&quot;1-1-基本概念&quot;&gt;&lt;a href=&quot;#1-1-基本概念&quot; class=&quot;headerlink&quot; title=&quot;1.1 基本概念&quot;&gt;&lt;/a&gt;1.1 基本概念&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;master：主节点，负责k8s调度，不应部署容器&lt;/li&gt;
&lt;li&gt;node：master之外的主机节点&lt;/li&gt;
&lt;li&gt;pod：一组容器的集合，在一个pod只部署一个容器时，可基本等价于容器实例&lt;/li&gt;
&lt;li&gt;deployment：一个容器、编排部署集合&lt;/li&gt;
&lt;li&gt;service：一个服务，简单理解deployment通过service暴露在网络中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，用deployment管理一组pod，用service暴露deployment。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Pod: 若干 container 组成的一个功能单元，共享相同的 IP / Namesapce / Volume&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://ifchanged.io/tags/docker/"/>
    
      <category term="kubernetes" scheme="http://ifchanged.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>git总结</title>
    <link href="http://ifchanged.io/2017/git%E6%80%BB%E7%BB%93/"/>
    <id>http://ifchanged.io/2017/git总结/</id>
    <published>2017-08-24T13:06:07.000Z</published>
    <updated>2017-09-09T09:17:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git中的位置"><a href="#git中的位置" class="headerlink" title="git中的位置"></a>git中的位置</h2><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p><img src="http://wx1.sinaimg.cn/large/663aa05agy1fidv3clywuj20ih07wdgn.jpg" alt="仓库"></p>
<ul>
<li><p><strong>工作目录</strong>：对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p>
</li>
<li><p><strong>暂存区</strong>：是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’’，不过一般说法还是叫暂存区域。</p>
</li>
<li><p><strong>Git仓库目录</strong>：是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p>
<ul>
<li><strong>远程仓库</strong>： 在网络上的仓库，和远程仓库交互的命令只有<code>git fetch</code>和<code>git push</code>，注意<code>git pull</code>实际上执行了fetch后自动执行了merge(默认)或rebase。 </li>
<li><strong>本地仓库</strong>：位于本地的仓库（.git\refs目录），包含本地的数据，有本地分支和追踪分支。</li>
</ul>
</li>
</ul>
<p>基本的 Git 工作流程如下：</p>
<ol>
<li>在工作目录中修改文件。</li>
<li>暂存文件，将文件的快照放入暂存区域。</li>
<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li>
</ol>
<ul>
<li>HEAD: 一个特殊指针，只想当前所在的本地分支，可以理解为当前分支的别名</li>
<li>head: 指向当前的commit</li>
</ul>
<p>参见: <a href="https://ndpsoftware.com/git-cheatsheet.html" target="_blank" rel="external">https://ndpsoftware.com/git-cheatsheet.html</a><br><a id="more"></a> </p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul>
<li>远程分支：如<strong>origin master</strong>，位于远程仓库</li>
<li>追踪分支：如<strong>origin/master</strong>，位于本地仓库（.git\refs\remotes），即git fetch到的位置。</li>
<li>本地分支:如<strong>master</strong>，位于本地仓库(.git\refs\heads)，执行merge、rebase、cherry后更新的分支</li>
</ul>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><img src="http://wx3.sinaimg.cn/large/663aa05agy1fidv3axzisj20sg0ifacj.jpg" alt="数据流"></p>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>参见：<a href="https://git-scm.com/book/zh/v2/Appendix-C%3A-Git-%E5%91%BD%E4%BB%A4-%E8%AE%BE%E7%BD%AE%E4%B8%8E%E9%85%8D%E7%BD%AE" target="_blank" rel="external">Appendix C: Git 命令</a></p>
<h3 id="快照基础"><a href="#快照基础" class="headerlink" title="快照基础"></a>快照基础</h3><ul>
<li><code>git add</code>命令将内容从工作目录添加到暂存区（或称为索引（index）区），以备下次提交</li>
<li><code>git status</code> 命令将为你展示工作区及暂存区域中不同状态的文件</li>
<li><code>git diff</code> 当需要查看任意两棵树的差异时你可以使用 git diff 命令。</li>
<li><code>git commit</code> 命令将所有通过 git add 暂存的文件内容在数据库中创建一个持久的快照，然后将当前分支上的分支指针移到其之上。</li>
<li><code>git reset</code> 命令主要用来根据你传递给动作的参数来执行撤销操作。理解为<strong>重置到</strong>。<strong>会修改commit记录，谨慎操作</strong><ul>
<li><code>git reset file.txt</code>： 取消暂存的文件</li>
<li><code>git reset e43a6fd3e94888d76779ad79fb568ed180e5fcdf</code>：重置到某个点<ul>
<li><code>--soft</code>（默认）：把文件从已commit的分支里扔到暂存区</li>
<li><code>--mixed</code>：把文件从已commit的分支里扔到暂存区（soft的操作），再把暂存区里新添加的文件扔出暂存区</li>
<li><code>--hard</code>:把文件从已commit的分支里扔到暂存区（soft的操作），再把所有东西<strong>扔出硬盘</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h3><ul>
<li><code>git branch</code> 命令实际上是某种程度上的分支管理工具。 它可以列出你所有的分支、创建新分支、删除分支及重命名分支。</li>
<li><code>git checkout</code> 命令用来切换分支，或者检出内容到工作目录。<ul>
<li><code>git checkout</code>：检出某个内容，如本地分支（切换分支）、追踪分支origin/master、某个commit 85bdab6b15、relog中的某个位置71a0f628d</li>
<li><code>git checkout -b/-B</code>：checkout为本地分支时切换分支，其他参数则检出内容后处在游离态(‘detached HEAD’ state),使用-b参数创建分支,-B参数强制创建分支</li>
<li><code>git chekcout -- a.txt</code>:此命令用于丢弃工作目录的修改</li>
</ul>
</li>
<li><code>git merge</code>工具用来合并一个或者多个分支到你已经检出的分支中。 然后它将当前分支指针移动到合并结果上。<ul>
<li>在merge中途，可以使用<code>git merge --abort</code>退出merge并取消修改</li>
</ul>
</li>
<li><code>git log</code> 命令用来展示一个项目的可达历史记录，从最近的提交快照起</li>
<li><code>git stash</code> git stash 命令用来临时地保存一些还没有提交的工作，以便在分支上不需要提交未完成工作就可以清理工作目录。</li>
</ul>
<h3 id="项目分享与更新"><a href="#项目分享与更新" class="headerlink" title="项目分享与更新"></a>项目分享与更新</h3><ul>
<li><code>git fetch</code> 命令与一个远程的仓库交互，并且将远程仓库中有但是在当前仓库的没有的所有信息拉取下来然后存储在你本地数据库中</li>
<li><code>git pull</code> 实际上就是fetch+merge（默认）或者fetch+rebase</li>
<li><code>git push</code> 命令用来与另一个仓库通信，计算你本地数据库与远程仓库的差异，然后将差异推送到另一个仓库中。 </li>
</ul>
<h3 id="检查与比较"><a href="#检查与比较" class="headerlink" title="检查与比较"></a>检查与比较</h3><ul>
<li><code>gut show</code>命令可以以一种简单的人类可读的方式来显示一个 Git 对象。 </li>
</ul>
<h3 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h3><ul>
<li><code>git cherry-pick</code>命令用来获得在单个提交中引入的变更，然后尝试将作为一个新的提交引入到你当前分支上。</li>
<li><code>git rebase</code>命令基本是是一个自动化的 cherry-pick 命令。 它计算出一系列的提交，然后再以它们在其他地方以同样的顺序一个一个的 cherry-picks 出它们。<strong>会修改commit记录，谨慎操作</strong><ul>
<li>在rebase中途，可以使用<code>git rebase --abort</code>退出并取消修改</li>
</ul>
</li>
<li><code>git revert</code> 命令本质上就是一个逆向的 git cherry-pick 操作。 它将你提交中的变更的以完全相反的方式的应用到一个新创建的提交中，本质上就是撤销或者倒转。</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="拣选工作流"><a href="#拣选工作流" class="headerlink" title="拣选工作流"></a>拣选工作流</h3><ul>
<li><p>场景： 提取某个commit到当前分支。</p>
</li>
<li><p>命令： <code>git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf</code></p>
</li>
<li><p>注意事项： 如果要提取多个commit，先提取前面的。</p>
</li>
<li><p>参考：<a href="https://git-scm.com/book/zh/v2/%E5%88%86%E5%B8%83%E5%BC%8F-Git-%E7%BB%B4%E6%8A%A4%E9%A1%B9%E7%9B%AE#_rebase_cherry_pick" target="_blank" rel="external">变基与拣选工作流</a></p>
</li>
</ul>
<h3 id="比较两个分支的commit"><a href="#比较两个分支的commit" class="headerlink" title="比较两个分支的commit"></a>比较两个分支的commit</h3><ul>
<li>命令:<ul>
<li><code>git rev-list ^master HEAD</code> ： 在当前分支但不在master分支的commit</li>
<li><code>git rev-list ^master HEAD|tail -1</code> : 寻找当前分支的开发起点</li>
<li><code>git rev-list A ^B --conut</code> 查找不同commit数量</li>
</ul>
</li>
</ul>
<ul>
<li>注意事项：<ul>
<li>可以增加<code>--pretty</code>参数美化日志结果，如<code>--pretty=oneline</code></li>
</ul>
</li>
</ul>
<h3 id="压缩commit"><a href="#压缩commit" class="headerlink" title="压缩commit"></a>压缩commit</h3><ul>
<li><p>场景：为了让log变得清晰，可以把多个commit合并成一个。但是如果commit较多，又或者经历过merg、cherry等命令，rebase将变得很麻烦。可以使用reset。</p>
</li>
<li><p>命令：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git rev-list ^origin/<span class="keyword">master</span> <span class="title">HEAD</span>|tail -<span class="number">1</span> <span class="comment"># 得到commit xxx</span></div><div class="line">git reset --soft xxx~<span class="number">1</span></div><div class="line">git commit -m <span class="string">"获得干净的提交"</span></div></pre></td></tr></table></figure>
</li>
<li><p>注意事项：为了防止误操作，可以使用<code>git branch bak1</code>备份分支，执行完上述命令后使用<code>git diff HEAD　bak1</code>进行比较差异，应得到没有差异的结果。</p>
</li>
</ul>
<h3 id="回滚分支合并"><a href="#回滚分支合并" class="headerlink" title="回滚分支合并"></a>回滚分支合并</h3><ul>
<li><p>场景： 一次分支合并时候，希望进行回滚</p>
</li>
<li><p>命令: <code>git revert -m parent-number commit</code>,如<code>git revert -m 1 08096c7c71429ac044a90bbd43f67aef13a91102</code></p>
</li>
</ul>
<p>一个典型的merge commit：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">commit a4aebedf433805eb15767f6f1905f3c236ce48bd</div><div class="line"><span class="symbol">Merge:</span> <span class="number">6</span>ee7688 d593ca7</div><div class="line"><span class="symbol">Author:</span> XXX <span class="params">&lt;XXX@qq.com&gt;</span></div><div class="line"><span class="symbol">Date:</span>   Mon Aug <span class="number">22</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">16</span> <span class="number">2016</span> +<span class="number">0800</span></div><div class="line">    XXXXX</div></pre></td></tr></table></figure></p>
<p>其中merge字段中的6ee7688 d593ca7就是两个parent commit，<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">      a4aebedf4</div><div class="line">         /\</div><div class="line"> 6ee7688|<span class="string"> </span>|d593ca7</div><div class="line">(master)|<span class="string"> </span>|<span class="string"> (feature)</span></div><div class="line">        |<span class="string"> </span>|</div><div class="line">        |<span class="string"> </span>|</div></pre></td></tr></table></figure></p>
<p>-m 参数指定要回滚到parent commit，值为1或2，即第1个还是第2个。如上图，我们想回滚掉feature分之，回到合并之前的master，则选择1。</p>
<ul>
<li>注意事项：通常使用Gitlab的merge request合并的分之都选1，当不确定时可以使用<code>git show xxxx</code>查看一下两个父节点分别是什么内容。</li>
</ul>
<h3 id="回滚到某个提交"><a href="#回滚到某个提交" class="headerlink" title="回滚到某个提交"></a>回滚到某个提交</h3><ul>
<li>场景：如果上线失败，想回滚到上次上线的版本，上线到昨天的某个版本等待。得到版本号后就可以回滚<strong>到</strong>那个版本。</li>
<li>命令：<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">reset</span> <span class="comment">--hard a4aebedf433805eb15767f6f1905f3c236ce48bd</span></div><div class="line">git <span class="keyword">reset</span> <span class="comment">--soft origin/master</span></div><div class="line">git <span class="keyword">commit</span> -am <span class="string">"revert to a4aebedf433805eb15767f6f1905f3c236ce48bd"</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="撤销本地操作"><a href="#撤销本地操作" class="headerlink" title="撤销本地操作"></a>撤销本地操作</h3><ul>
<li>场景： 如删除错分支，reset命令错commit时，可以使用relog查看操作日志，并撤销操作。</li>
<li><p>命令:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git reflog <span class="comment"># 查找需要恢复到的id</span></div><div class="line">git reset <span class="comment">--head XXX</span></div></pre></td></tr></table></figure>
</li>
<li><p>注意事项：reflog只记录HEAD的值，即每一次提交或改变分支，所以没有commit的内容无法用reflog恢复。</p>
</li>
<li>参考：<a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-%E7%BB%B4%E6%8A%A4%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D" target="_blank" rel="external">维护与数据恢复</a></li>
</ul>
<h3 id="把本地重置到远程分支的版本"><a href="#把本地重置到远程分支的版本" class="headerlink" title="把本地重置到远程分支的版本"></a>把本地重置到远程分支的版本</h3><ul>
<li>场景: 如获取最新的master或某个分支覆盖本地代码</li>
<li>命令：</li>
</ul>
<p>把当前的分支变为远程某分支<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git fetch </div><div class="line">git <span class="built_in">reset</span> --hard <span class="built_in">origin</span>/master</div></pre></td></tr></table></figure></p>
<p>或</p>
<p>检出某个远程分支强制到某本地分支</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git fetch</div><div class="line">git checkout origin/<span class="keyword">master</span> <span class="title">-B</span> <span class="literal">master</span></div></pre></td></tr></table></figure>
<h3 id="二分查找问题commit"><a href="#二分查找问题commit" class="headerlink" title="二分查找问题commit"></a>二分查找问题commit</h3><ul>
<li>场景：比如一次上线有多个pr带来的代码，本地分支commit几次后发现有问题，用二分查找快速的定位问题</li>
<li><p>命令：</p>
<ul>
<li>暴力checkout法：手动git checkout  HEAD~1，HEAD~10,HEAD~5这样手动切换到某个commit</li>
<li><p>bisect命令：</p>
  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">bisect </span>start <span class="comment">#标记开始</span></div><div class="line">git <span class="keyword">bisect </span><span class="keyword">bad </span><span class="comment"># 标记当前有问题 </span></div><div class="line">git <span class="keyword">bisect </span>good <span class="built_in">v1</span>.<span class="number">0</span> 标记一个没问题的起点</div></pre></td></tr></table></figure>
<p>  而后git会自动开始二分查找，用户使用git bisect bad或者git bisect good进行标记当前commit的情况，直到能确定因为问题的commit。</p>
</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>git有工作目录、暂存区、仓库三个位置，里面有所有的git追踪的内容。使用<code>git checkout</code>能够<strong>检出（获得）</strong>分支中的内容，<code>git reset</code>能够<strong>重置</strong>到某个点。<code>git diff</code>比较文件，<code>git rev-list</code>比较commit。<code>git log</code>查看commit日志，<code>git reflog</code>查看本地<code>HEAD</code>移动记录。</p>
<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul>
<li>《Pro Git》 <a href="https://git-scm.com/book/zh/v2" target="_blank" rel="external">https://git-scm.com/book/zh/v2</a><ul>
<li><a href="https://git-scm.com/book/zh/v2/Appendix-C%3A-Git-%E5%91%BD%E4%BB%A4-%E8%AE%BE%E7%BD%AE%E4%B8%8E%E9%85%8D%E7%BD%AE" target="_blank" rel="external">Appendix C: Git 命令</a></li>
</ul>
</li>
<li>Reference <a href="https://git-scm.com/docs" target="_blank" rel="external">https://git-scm.com/docs</a></li>
<li>User manual: <a href="https://git-scm.com/docs/user-manual.html" target="_blank" rel="external">https://git-scm.com/docs/user-manual.html</a></li>
<li><a href="https://www.atlassian.com/git" target="_blank" rel="external">https://www.atlassian.com/git</a></li>
<li>git everyday <a href="https://git-scm.com/docs/everyday" target="_blank" rel="external">https://git-scm.com/docs/everyday</a></li>
<li><a href="http://ladder1984.github.io/tags/git/" target="_blank" rel="external">http://ladder1984.github.io/tags/git/</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;git中的位置&quot;&gt;&lt;a href=&quot;#git中的位置&quot; class=&quot;headerlink&quot; title=&quot;git中的位置&quot;&gt;&lt;/a&gt;git中的位置&lt;/h2&gt;&lt;h3 id=&quot;仓库&quot;&gt;&lt;a href=&quot;#仓库&quot; class=&quot;headerlink&quot; title=&quot;仓库&quot;&gt;&lt;/a&gt;仓库&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://wx1.sinaimg.cn/large/663aa05agy1fidv3clywuj20ih07wdgn.jpg&quot; alt=&quot;仓库&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;工作目录&lt;/strong&gt;：对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;暂存区&lt;/strong&gt;：是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’’，不过一般说法还是叫暂存区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Git仓库目录&lt;/strong&gt;：是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;远程仓库&lt;/strong&gt;： 在网络上的仓库，和远程仓库交互的命令只有&lt;code&gt;git fetch&lt;/code&gt;和&lt;code&gt;git push&lt;/code&gt;，注意&lt;code&gt;git pull&lt;/code&gt;实际上执行了fetch后自动执行了merge(默认)或rebase。 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本地仓库&lt;/strong&gt;：位于本地的仓库（.git\refs目录），包含本地的数据，有本地分支和追踪分支。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本的 Git 工作流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在工作目录中修改文件。&lt;/li&gt;
&lt;li&gt;暂存文件，将文件的快照放入暂存区域。&lt;/li&gt;
&lt;li&gt;提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;HEAD: 一个特殊指针，只想当前所在的本地分支，可以理解为当前分支的别名&lt;/li&gt;
&lt;li&gt;head: 指向当前的commit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参见: &lt;a href=&quot;https://ndpsoftware.com/git-cheatsheet.html&quot;&gt;https://ndpsoftware.com/git-cheatsheet.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="第一站" scheme="http://ifchanged.io/tags/%E7%AC%AC%E4%B8%80%E7%AB%99/"/>
    
      <category term="git" scheme="http://ifchanged.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>浅谈行为驱动开发(BDD)</title>
    <link href="http://ifchanged.io/2017/%E6%B5%85%E8%B0%88%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91(BDD)/"/>
    <id>http://ifchanged.io/2017/浅谈行为驱动开发(BDD)/</id>
    <published>2017-05-15T16:45:44.000Z</published>
    <updated>2017-09-09T09:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>BDD（Behaviour-Driven Development行为驱动开发）是一种敏捷开放方式，鼓励开发者、测试、业务方参与开发协作，虽然多数情况下只有开发和测试参与。BDD使用自然语言描述用户故事，从而让各方都可读、可写测试用例，并且用通用的语言精确描述软件的行为。</p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>一种测试方案，模拟用户的真实行为，来保证各个软件模块执行后的最终结果是正确的。</p>
<a id="more"></a> 
<h2 id="运作方式"><a href="#运作方式" class="headerlink" title="运作方式"></a>运作方式</h2><h3 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h3><p>用Gherkin语法描述step，一个个关联且有序的step组成完整的scenario，相关的scenario放入一个feature文件中。</p>
<h3 id="Gherkin语法"><a href="#Gherkin语法" class="headerlink" title="Gherkin语法"></a>Gherkin语法</h3><ul>
<li>Given：把系统置为某种状态，也就是准备数据</li>
<li>When：描述用户行为，也就是要测试的step</li>
<li>Then：获得结果，通常用于校验</li>
<li>And：表示使用上一个step的关键词</li>
</ul>
<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>用tag来标记不同模块，也用tag来标记通过和未通过的scenario</p>
<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>令人怀念的<code>behave -kt @xxx</code>命令</p>
<h3 id="Jenkins执行"><a href="#Jenkins执行" class="headerlink" title="Jenkins执行"></a>Jenkins执行</h3><p>可用Jenkins输出完整报告。在Jenkins执行时可用tag或目录分割多组feature，则并行执行，理论最短时间为最长scenario的耗时。</p>
<p>参考：</p>
<ul>
<li><a href="https://github.com/cucumber/cucumber/wiki/Given-When-Then" target="_blank" rel="external">Gherkin</a></li>
<li><a href="https://github.com/cucumber/cucumber/wiki/Given-When-Then" target="_blank" rel="external">Given When Then</a></li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>以用户故事为测试单位，保证软件在真实、连贯场景中的正确性。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>当业务越来复杂、微服务越来越多时，这种集成测试方案难以维护，对开发者要求较高。在没有良好并行方案时，速度很慢。</p>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul>
<li>库：behave，其他Python库实现：Lettuce、radish</li>
<li>处理异步：celery使用同步模式、异步消息消费者采用子进程阻塞调用</li>
<li>夸服务调用：BDD SERVER，使用http服务器传递step，并使用sub step调用，用http response返回结果</li>
<li>第三方服务：各种mock</li>
<li>IDE支持：Pycharm</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;BDD（Behaviour-Driven Development行为驱动开发）是一种敏捷开放方式，鼓励开发者、测试、业务方参与开发协作，虽然多数情况下只有开发和测试参与。BDD使用自然语言描述用户故事，从而让各方都可读、可写测试用例，并且用通用的语言精确描述软件的行为。&lt;/p&gt;
&lt;h3 id=&quot;核心思想&quot;&gt;&lt;a href=&quot;#核心思想&quot; class=&quot;headerlink&quot; title=&quot;核心思想&quot;&gt;&lt;/a&gt;核心思想&lt;/h3&gt;&lt;p&gt;一种测试方案，模拟用户的真实行为，来保证各个软件模块执行后的最终结果是正确的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="第一站" scheme="http://ifchanged.io/tags/%E7%AC%AC%E4%B8%80%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>git tag应用</title>
    <link href="http://ifchanged.io/2017/git-tag%E5%BA%94%E7%94%A8/"/>
    <id>http://ifchanged.io/2017/git-tag应用/</id>
    <published>2017-02-28T06:59:13.000Z</published>
    <updated>2017-09-09T09:18:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Tag概述"><a href="#1-Tag概述" class="headerlink" title="1. Tag概述"></a>1. Tag概述</h2><blockquote>
<p>像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。</p>
</blockquote>
<p>参考：  </p>
<ul>
<li><a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="external">https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE</a></li>
<li><code>git help tag</code></li>
</ul>
<h3 id="1-1-命令"><a href="#1-1-命令" class="headerlink" title="1.1 命令"></a>1.1 命令</h3><p>tag的命令与分支相似。</p>
<ul>
<li>列出标签: <code>git tag</code></li>
<li>创建标签: <code>git tag tag123</code><ul>
<li>附注标签: <code>git tag -a v1.4 -m &#39;my version 1.4&#39;</code></li>
<li>打在制定版本: <code>git tag -a v1.2 9fceb02</code> </li>
</ul>
</li>
<li>查看标签内容: <code>git show v1.4</code> 或 <code>git log v1.4</code><ul>
<li>按照版本排序：<code>git tag --sort=&quot;version:refname</code></li>
<li>搜索： <code>git tag -l &lt;pattern&gt;</code>，如<code>git tag -l &quot;v*&quot;</code></li>
</ul>
</li>
<li>push标签：git push不会推送本地标签<ul>
<li>push特定标签： <code>git push origin [tagname]</code></li>
<li>push所有标签： <code>git push origin --tags</code></li>
</ul>
</li>
<li>检出标签: <code>git checkout -b version2 v2.0.0</code></li>
<li>删除标签：<ul>
<li>删除本地标签: <code>git tag -d v0.1</code>      批量：<code>git tag -l &quot;vTEST*&quot;|xargs git tag -d</code></li>
<li>删除远程标签: <code>git push origin --delete v0.1</code>   批量：<code>git tag -l &quot;vTEST*&quot;|xargs git push origin --delete</code></li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><h3 id="2-1-jenkins"><a href="#2-1-jenkins" class="headerlink" title="2.1 jenkins"></a>2.1 jenkins</h3><p>增加构建后操作的Publisher：</p>
<p><img src="/images/git_tag1.png" alt=""></p>
<ul>
<li>v168形式的标签表示每次 jenkins上线构建的版本,使用<code>git tag --sort=&quot;version:refname&quot; -l &quot;v*&quot;</code>获得按照版本排序的tag。</li>
</ul>
<h3 id="2-2-Gitlab"><a href="#2-2-Gitlab" class="headerlink" title="2.2 Gitlab"></a>2.2 Gitlab</h3><p>需要添加jenkins用户为develop权限。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol>
<li>比较</li>
</ol>
<ul>
<li>文件比较：<code>git diff v98 master</code>,此命令比较v98和master文件不同。常用于比较两个版本是否一致。</li>
<li><p>commit：<code>git diff ^v98 master</code>，此命令比较不在v98上但是在master上的commit有哪些。常用于比较两个版本不同的commit</p>
<ul>
<li><p>取得远程master上没有上线的commit：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git fetch &amp;&amp; git log `git <span class="keyword">tag</span> <span class="title">--sort</span>=<span class="string">"version:refname"</span> -l <span class="string">"v*"</span>|tail -<span class="number">1</span>`..origin/<span class="literal">master</span></div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git fetch &amp;&amp; git rev-list ^`git <span class="keyword">tag</span> <span class="title">--sort</span>=<span class="string">"version:refname"</span> -l <span class="string">"v*"</span>|tail -<span class="number">1</span>` origin/<span class="keyword">master</span> <span class="title">--pretty</span>=oneline</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><strong>注</strong>：<code>--sort=&quot;version:refname&quot; -l &quot;v*&quot;</code>要求v开头的tag都是jenkins打出来的，且要求git 2.1及以上版本</p>
<ol>
<li>回滚</li>
</ol>
<p>todo</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Tag概述&quot;&gt;&lt;a href=&quot;#1-Tag概述&quot; class=&quot;headerlink&quot; title=&quot;1. Tag概述&quot;&gt;&lt;/a&gt;1. Tag概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE&quot;&gt;https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git help tag&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;1-1-命令&quot;&gt;&lt;a href=&quot;#1-1-命令&quot; class=&quot;headerlink&quot; title=&quot;1.1 命令&quot;&gt;&lt;/a&gt;1.1 命令&lt;/h3&gt;&lt;p&gt;tag的命令与分支相似。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列出标签: &lt;code&gt;git tag&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建标签: &lt;code&gt;git tag tag123&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;附注标签: &lt;code&gt;git tag -a v1.4 -m &amp;#39;my version 1.4&amp;#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;打在制定版本: &lt;code&gt;git tag -a v1.2 9fceb02&lt;/code&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;查看标签内容: &lt;code&gt;git show v1.4&lt;/code&gt; 或 &lt;code&gt;git log v1.4&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;按照版本排序：&lt;code&gt;git tag --sort=&amp;quot;version:refname&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;搜索： &lt;code&gt;git tag -l &amp;lt;pattern&amp;gt;&lt;/code&gt;，如&lt;code&gt;git tag -l &amp;quot;v*&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;push标签：git push不会推送本地标签&lt;ul&gt;
&lt;li&gt;push特定标签： &lt;code&gt;git push origin [tagname]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;push所有标签： &lt;code&gt;git push origin --tags&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;检出标签: &lt;code&gt;git checkout -b version2 v2.0.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除标签：&lt;ul&gt;
&lt;li&gt;删除本地标签: &lt;code&gt;git tag -d v0.1&lt;/code&gt;      批量：&lt;code&gt;git tag -l &amp;quot;vTEST*&amp;quot;|xargs git tag -d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除远程标签: &lt;code&gt;git push origin --delete v0.1&lt;/code&gt;   批量：&lt;code&gt;git tag -l &amp;quot;vTEST*&amp;quot;|xargs git push origin --delete&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://ifchanged.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git master分支回滚指南</title>
    <link href="http://ifchanged.io/2016/git%20mater%E5%88%86%E6%94%AF%E5%9B%9E%E6%BB%9A%E6%8C%87%E5%8D%97/"/>
    <id>http://ifchanged.io/2016/git mater分支回滚指南/</id>
    <published>2016-08-24T15:44:27.000Z</published>
    <updated>2017-03-03T16:59:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-master分支回滚的特殊性"><a href="#1-1-master分支回滚的特殊性" class="headerlink" title="1.1 master分支回滚的特殊性"></a>1.1 master分支回滚的特殊性</h3><ol>
<li>多人协作，修改提交历史的方式易造成冲突</li>
<li>希望所有操作的记录都是保存的，避免丢失代码</li>
<li>希望没有master权限的人也能按照正常合并流程进行回滚</li>
</ol>
<p>所以，以下的方法都是不会修改提交历史了，操作可以使用正常合并流程。</p>
<h3 id="1-2-场景描述"><a href="#1-2-场景描述" class="headerlink" title="1.2 场景描述"></a>1.2 场景描述</h3><ol>
<li>回滚某个或某些commit</li>
<li>回滚分支合并（merge commit）</li>
<li>回滚<strong>到</strong>某个提交</li>
</ol>
<h2 id="2-回滚方法"><a href="#2-回滚方法" class="headerlink" title="2. 回滚方法"></a>2. 回滚方法</h2><h3 id="2-1-回滚某个或某些commit"><a href="#2-1-回滚某个或某些commit" class="headerlink" title="2.1 回滚某个或某些commit"></a>2.1 回滚某个或某些commit</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">git</span> <span class="keyword">revert </span>commit</div></pre></td></tr></table></figure>
<p>如：<code>git revet 08096c7</code></p>
<h3 id="2-2-回滚分支合并（merge-commit）"><a href="#2-2-回滚分支合并（merge-commit）" class="headerlink" title="2.2 回滚分支合并（merge commit）"></a>2.2 回滚分支合并（merge commit）</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git revert -m parent-<span class="built_in">number</span> commit</div></pre></td></tr></table></figure>
<p>如<code>git revert -m 1 08096c7c71429ac044a90bbd43f67aef13a91102</code></p>
<p>一个典型的merge commit：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">commit a4aebedf433805eb15767f6f1905f3c236ce48bd</div><div class="line"><span class="symbol">Merge:</span> <span class="number">6</span>ee7688 d593ca7</div><div class="line"><span class="symbol">Author:</span> XXX <span class="params">&lt;XXX@qq.com&gt;</span></div><div class="line"><span class="symbol">Date:</span>   Mon Aug <span class="number">22</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">16</span> <span class="number">2016</span> +<span class="number">0800</span></div><div class="line"></div><div class="line">    XXXXX</div></pre></td></tr></table></figure></p>
<p>其中merge字段中的6ee7688 d593ca7就是两个parent commit，<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">      a4aebedf4</div><div class="line">         /\</div><div class="line"> 6ee7688|<span class="string"> </span>|d593ca7</div><div class="line">(master)|<span class="string"> </span>|<span class="string"> (feature)</span></div><div class="line">        |<span class="string"> </span>|</div><div class="line">        |<span class="string"> </span>|</div></pre></td></tr></table></figure></p>
<p>-m 参数指定要回滚到parent commit，值为1或2，即第1个还是第2个。如上图，我们想回滚<strong>掉</strong>feature分之，回<strong>到</strong>合并之前的master，则选择1.通常使用Gitlab的merge request合并的分之都选1.</p>
<h3 id="2-3-回滚到某个提交"><a href="#2-3-回滚到某个提交" class="headerlink" title="2.3 回滚到某个提交"></a>2.3 回滚到某个提交</h3><p>如要把master回滚到tag v100:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">reset</span> <span class="comment">--hard v100</span></div><div class="line">git <span class="keyword">reset</span> <span class="comment">--soft origin/master</span></div><div class="line">git <span class="keyword">commit</span> -am <span class="string">"revert to v100"</span></div></pre></td></tr></table></figure></p>
<p>回滚完毕后，可以使用<code>git diff head v100</code>比较是否还有不同，如果有不同，则说明操作错误。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;h3 id=&quot;1-1-master分支回滚的特殊性&quot;&gt;&lt;a href=&quot;#1-1-master分支回滚的特殊性&quot; class
    
    </summary>
    
    
      <category term="git" scheme="http://ifchanged.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>peewee笔记(2)——构建自已的peewee文档</title>
    <link href="http://ifchanged.io/2016/peewee-note2/"/>
    <id>http://ifchanged.io/2016/peewee-note2/</id>
    <published>2016-03-28T12:17:01.000Z</published>
    <updated>2017-01-08T14:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>开源软件的一大好处就是我们可以根据自己的需要进行定制或优化，但这带来的问题是，修改可能无法合并的回社区。随着时间流逝，自己的版本可能和官方版本差别越来越大，也无法合并官方的代码更新。如果后续开发者一直阅读官方文档就会有问题，所有需要构建自己的文档。</p>
<p>打开peewee官方文档<a href="http://docs.peewee-orm.com/en/latest/" target="_blank" rel="external">http://docs.peewee-orm.com/en/latest/</a>，我们可以看到只提供latest、stable版本文档，可能和我们定制的已经千差万别。好在peewee文档使用Sphinx构建，易于修改部署。</p>
<h2 id="部署文档"><a href="#部署文档" class="headerlink" title="部署文档"></a>部署文档</h2><p>好在github上我们可以找到历史版本的文档，以2.6.4为例。</p>
<ol>
<li>安装Sphinx：<code>pip install sphinx</code></li>
<li>从官方git（<a href="https://github.com/coleifer/peewee" target="_blank" rel="external">https://github.com/coleifer/peewee</a>）下载peewee源码并切换到tag 2.6.4。</li>
<li>进入项目内doc/目录，执行<code>make.bat html</code>(Windows)或<code>make html</code>(Linux)生成静态网站目录_build/index/ 。</li>
<li>把2的目录找个服务器放。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;开源软件的一大好处就是我们可以根据自己的需要进行定制或优化，但这带来的问题是，修改可能无法合并的回社区。随着时间流逝，自己的版本可能和官方版
    
    </summary>
    
    
      <category term="Python" scheme="http://ifchanged.io/tags/Python/"/>
    
      <category term="MySQL" scheme="http://ifchanged.io/tags/MySQL/"/>
    
      <category term="peewee" scheme="http://ifchanged.io/tags/peewee/"/>
    
  </entry>
  
  <entry>
    <title>peewee笔记(1)——基本语法</title>
    <link href="http://ifchanged.io/2016/peewee-note1/"/>
    <id>http://ifchanged.io/2016/peewee-note1/</id>
    <published>2016-03-23T02:44:27.000Z</published>
    <updated>2017-01-08T14:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="peewee使用指南"><a href="#peewee使用指南" class="headerlink" title="peewee使用指南"></a>peewee使用指南</h1><p>本系列文章基于peewee 2.6.4，同时会参照Django Orm做点比较。</p>
<h2 id="1-peewee介绍"><a href="#1-peewee介绍" class="headerlink" title="1.peewee介绍"></a>1.peewee介绍</h2><p>peewee是一个轻量级Python ORM，支持Sqlite、MYSQL、PostgresqlD等数据库。</p>
<h2 id="2-使用指南"><a href="#2-使用指南" class="headerlink" title="2.使用指南"></a>2.使用指南</h2><h3 id="2-1-连接mysql"><a href="#2-1-连接mysql" class="headerlink" title="2.1.连接mysql"></a>2.1.连接mysql</h3><h4 id="2-1-1-连接形式"><a href="#2-1-1-连接形式" class="headerlink" title="2.1.1.连接形式"></a>2.1.1.连接形式</h4><p>使用url连接，方式和django类似，如：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">DATABASES = &#123;</div><div class="line">    <span class="string">'default'</span>: &#123;</div><div class="line">        <span class="string">'ENGINE'</span>: <span class="string">'mysql'</span>,</div><div class="line">        <span class="string">'NAME'</span>: <span class="string">'name'</span>,</div><div class="line">        <span class="string">'USER'</span>: <span class="string">'user'</span>,                      </div><div class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'pass'</span>,                  </div><div class="line">        <span class="string">'HOST'</span>: <span class="string">'url'</span>,</div><div class="line">        <span class="string">'PORT'</span>: <span class="string">''</span>,</div><div class="line">        <span class="string">'CONN_MAX_AGE'</span>: <span class="number">100</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-2-model定义"><a href="#2-2-model定义" class="headerlink" title="2.2.model定义"></a>2.2.model定义</h3><h4 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1.概述"></a>2.2.1.概述</h4><p>一句话描述：<strong>和Django一样用。</strong></p>
<p>model定义基本和Django一致，<br>需要注意的是：</p>
<ol>
<li>属性和Django基本一致</li>
<li>有些Django并不影响使用的东西peewee不支持，目前注意到的是<code>Field.choices</code>。</li>
<li>peewee可以使用<code>playhouse.signals</code>实现信号机制。</li>
</ol>
<p>详见：<a href="http://docs.peewee-orm.com/en/stable/peewee/models.html#fields" target="_blank" rel="external">http://docs.peewee-orm.com/en/stable/peewee/models.html#fields</a></p>
<h2 id="3-ORM操作（CRUD）"><a href="#3-ORM操作（CRUD）" class="headerlink" title="3.ORM操作（CRUD）"></a>3.ORM操作（CRUD）</h2><p>示例Model：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> peewee <span class="keyword">import</span> *</div><div class="line"></div><div class="line">db = SqliteDatabase(<span class="string">'people.db'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(Model)</span>:</span></div><div class="line">    name = CharField(default=<span class="string">''</span>)</div><div class="line">    age = IntegerField(default=<span class="number">0</span>) </div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></div><div class="line">        database = db <span class="comment"># This model uses the "people.db" database.</span></div></pre></td></tr></table></figure>
<p>注：这是个model示例，实际上’database=db’已经封装在<code>db.model.Model</code>中，在python-service-base中不用写。</p>
<h3 id="3-1-增加（Create）"><a href="#3-1-增加（Create）" class="headerlink" title="3.1.增加（Create）"></a>3.1.增加（Create）</h3><ol>
<li>create()方法：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grandma =Person.create(name=<span class="string">'Grandma'</span>, age = <span class="number">1</span>)</div></pre></td></tr></table></figure>
<ol>
<li>save()方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">person = Person()</div><div class="line">person.name = <span class="string">'bill'</span></div><div class="line">person.age =<span class="number">10</span></div><div class="line">person.save()</div></pre></td></tr></table></figure>
<h3 id="3-2-查（Retrieve）"><a href="#3-2-查（Retrieve）" class="headerlink" title="3.2.查（Retrieve）"></a>3.2.查（Retrieve）</h3><p>peewee中查询记录分为get（查询单条记录）、select(条件查询批量记录)。</p>
<h4 id="3-2-1-查询单条记录"><a href="#3-2-1-查询单条记录" class="headerlink" title="3.2.1.查询单条记录"></a>3.2.1.查询单条记录</h4><p>注：get方法获取不存在的记录会抛出异常。</p>
<ol>
<li><p><code>Product.get(name=&#39;abc&#39;)</code><br>或者<br><code>Product.get(Product.name==&#39;abc&#39;)</code></p>
</li>
<li><p><code>Product.select().where(Product.name==&#39;abc&#39;).get()</code></p>
</li>
<li><code>Product.select().where(Product.name==&#39;abc&#39;).first()</code></li>
</ol>
<p><strong>注:</strong></p>
<ol>
<li>get()支持name=’abc’也支持Product.name==’abc’的写法，where<strong>只</strong>Product.name==’abc’。</li>
<li>前两种都是get方法，查询不到会抛出异常，select方法查询不到返回None。</li>
</ol>
<h4 id="3-2-2-查询全部"><a href="#3-2-2-查询全部" class="headerlink" title="3.2.2.查询全部"></a>3.2.2.查询全部</h4><p><code>Product.select()</code>等价于Django中的<code>Product.select().all()</code>，返回一个可迭代的SelectQuery对象。</p>
<h4 id="3-2-3-条件查询"><a href="#3-2-3-条件查询" class="headerlink" title="3.2.3.条件查询"></a>3.2.3.条件查询</h4><figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Product</span>.<span class="keyword">select</span>().<span class="keyword">where</span>(<span class="built_in">Product</span>.<span class="keyword">name</span>==<span class="string">'abc'</span>)</div></pre></td></tr></table></figure>
<p>返回一个可迭代的SelectQuery对象。</p>
<ul>
<li>或(OR)查询：<strong>|</strong>，例如：<code>User.select().where((User.is_staff == True) | (User.is_superuser == True))</code></li>
<li>且(AND)查询:<strong>&amp;</strong>，例如：<code>Product.select().where(Product.name==&#39;abc&#39;,Product.owner_id==10086)</code> 或者 <code>Product.select().where((Product.name==&#39;abc&#39;) &amp; (Product.owner_id==10086))</code></li>
<li>非(NOT)：<strong>~</strong>,没用过。。。</li>
<li><p>比较：peewee支持如下比较符</p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">==  x <span class="keyword">equals</span> y</div><div class="line">&lt;   x <span class="keyword">is</span> <span class="keyword">less than</span> y</div><div class="line">&lt;=  x <span class="keyword">is</span> <span class="keyword">less than or equal</span> <span class="keyword">to</span> y</div><div class="line">&gt;   x <span class="keyword">is</span> <span class="keyword">greater than</span> y</div><div class="line">&gt;=  x <span class="keyword">is</span> <span class="keyword">greater than</span> <span class="keyword">or</span> <span class="keyword">equal</span> <span class="keyword">to</span> y</div><div class="line">!=  x <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">equal</span> <span class="keyword">to</span> y</div><div class="line">&lt;&lt;  x IN y, <span class="keyword">where</span> y <span class="keyword">is</span> a <span class="built_in">list</span> <span class="keyword">or</span> query</div><div class="line">&gt;&gt;  x IS y, <span class="keyword">where</span> y <span class="keyword">is</span> None/NULL</div><div class="line">%   x LIKE y <span class="keyword">where</span> y may <span class="keyword">contain</span> wildcards</div><div class="line">**  x ILIKE y <span class="keyword">where</span> y may <span class="keyword">contain</span> wildcards</div><div class="line">~   Negation</div></pre></td></tr></table></figure>
</li>
<li><p>其他查询</p>
  <figure class="highlight vbnet"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.contains(substr) 	Wild-card search <span class="keyword">for</span> substring.</div><div class="line">.startswith(prefix) 	Search <span class="keyword">for</span> values beginning <span class="keyword">with</span> prefix.</div><div class="line">.endswith(suffix) 	Search <span class="keyword">for</span> values ending <span class="keyword">with</span> suffix.</div><div class="line">.between(low, high) 	Search <span class="keyword">for</span> values between low <span class="keyword">and</span> high.</div><div class="line">.regexp(exp) 	Regular expression match.</div><div class="line">.bin_and(value) 	<span class="keyword">Binary</span> <span class="keyword">AND</span>.</div><div class="line">.bin_or(value) 	<span class="keyword">Binary</span> <span class="keyword">OR</span>.</div><div class="line">.in_(value) 	<span class="keyword">IN</span> lookup (identical <span class="keyword">to</span> &lt;&lt;).</div><div class="line">.not_in(value) 	<span class="keyword">NOT</span> <span class="keyword">IN</span> lookup.</div><div class="line">.is_null(is_null) 	<span class="keyword">IS</span> NULL <span class="keyword">or</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> NULL. Accepts <span class="built_in">boolean</span> param.</div><div class="line">.concat(other) 	Concatenate two strings <span class="keyword">using</span> ||.</div></pre></td></tr></table></figure>
</li>
</ul>
<p>示例：</p>
<p>查询id in ids，ids是个list。</p>
<ul>
<li><code>Product.select().where(Product.id &lt;&lt; ids)</code></li>
<li><code>Product.select().where(Product.id.in_(ids))</code></li>
</ul>
<p>等价于Django中的<code>Product.objects.filter(id__=ids)</code>。</p>
<h4 id="3-2-3-计数count"><a href="#3-2-3-计数count" class="headerlink" title="3.2.3.计数count"></a>3.2.3.计数count</h4><p><code>Product.select().where(Product.name==&#39;abc&#39;).count()</code>。<br>SelectQuery对象并不支持len()方法，即执行<code>len(Product.select().where(Product.name==&#39;abc&#39;))</code>会抛出TypeError异常。虽然可以实现支持len，但滥用可能带来性能风险。</p>
<h4 id="3-2-5-排序order-by"><a href="#3-2-5-排序order-by" class="headerlink" title="3.2.5.排序order_by"></a>3.2.5.排序order_by</h4><ul>
<li>降序：使用”-“或者”desc()”,<code>Tweet.select().order_by(Tweet.created_date.desc())</code> 等价于 <code>Tweet.select().order_by(-Tweet.created_date)</code></li>
<li>升序：使用”+”或者”asc()”或者不写，<code>User.select().order_by(+User.username)</code></li>
</ul>
<h3 id="3-3-删除（Delete）"><a href="#3-3-删除（Delete）" class="headerlink" title="3.3.删除（Delete）"></a>3.3.删除（Delete）</h3><p><strong>建议使用方法1</strong></p>
<ol>
<li>Model.delete (Python class method, in API Reference)<br><code>mall_models.Order.delete().where(mall_models.Order.id=order.id).execute()</code><br>或者<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = mall_models.Order.delete().where(mall_models.Order.id=order.id)</div><div class="line">p.execute()</div></pre></td></tr></table></figure>
</li>
</ol>
<p>也就是执行了execute()才会执行删除操作。</p>
<ol>
<li><p>Model.delete_instance (Python method, in API Reference)</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">p</span> = Product.get(Product.name==<span class="string">'abc'</span>)</div><div class="line"><span class="selector-tag">p</span>.elete_instance()</div></pre></td></tr></table></figure>
</li>
<li><p>DeleteQuery<br><code>dq = DeleteQuery(User).where(User.active == False).execute()</code></p>
</li>
</ol>
<h3 id="3-4-改（Update）"><a href="#3-4-改（Update）" class="headerlink" title="3.4.改（Update）"></a>3.4.改（Update）</h3><ol>
<li>update修改(推荐)<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">query = Stat.update(counter=Stat.counter + <span class="number">1</span>).where(Stat.url == request.url)</div><div class="line">query.execute()</div></pre></td></tr></table></figure>
</li>
</ol>
<p>同delete,也就是执行了execute()才会执行update操作。</p>
<ol>
<li>save修改<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> stat <span class="keyword">in</span> Stat.select().where(Stat.url == request.url):</div><div class="line">     stat.counter += <span class="number">1</span></div><div class="line">     stat.save()</div></pre></td></tr></table></figure>
</li>
</ol>
<p>两种方式都类似Django语句，<strong>需要特别注意的是，peewee的update是原子的（Atomic ）</strong>，在并发情况下可靠，即peewee的update语句效果等价于Django使用F表达式的update，如<code>rules.update(remained_count=F(&#39;remained_count&#39;) - 1, get_count=F(&#39;get_count&#39;) + 1)</code></p>
<h2 id="4-外键与join"><a href="#4-外键与join" class="headerlink" title="4.外键与join"></a>4.外键与join</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderHasProduct</span><span class="params">(models.Model)</span>:</span></div><div class="line">	order = models.ForeignKey(Order)</div><div class="line">	product = models.ForeignKey(Product, related_name=<span class="string">'product'</span>)</div><div class="line">	price = models.FloatField()  <span class="comment"># 商品单价</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span><span class="params">(models.Model)</span>:</span></div><div class="line">	order_id = models.CharField(max_length=<span class="number">100</span>)  <span class="comment"># 订单号</span></div><div class="line">	webapp_user_id = models.IntegerField()  <span class="comment"># WebApp用户的id</span></div><div class="line">	webapp_id = models.CharField(max_length=<span class="number">20</span>, verbose_name=<span class="string">'店铺ID'</span>)  <span class="comment"># webapp,订单成交的店铺id</span></div><div class="line">	webapp_source_id = models.IntegerField(default=<span class="number">0</span>, verbose_name=<span class="string">'商品来源店铺ID'</span>)  <span class="comment"># 订单内商品实际来源店铺的id，已废弃</span></div><div class="line">	buyer_name = models.CharField(max_length=<span class="number">100</span>)  <span class="comment"># 购买人姓名</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span><span class="params">(models.Model)</span>:</span></div><div class="line">	owner = models.ForeignKey(User, related_name=<span class="string">'user-product'</span>)</div><div class="line">	name = models.CharField(max_length=<span class="number">256</span>)  <span class="comment"># 商品名称</span></div><div class="line">	physical_unit = models.CharField(default=<span class="string">''</span>, max_length=<span class="number">256</span>)  <span class="comment"># 计量单位</span></div><div class="line">	price = models.FloatField(default=<span class="number">0.0</span>)  <span class="comment"># 商品价格</span></div></pre></td></tr></table></figure>
<p>OrderHasProduct有外键Product和外键Order。</p>
<h3 id="4-1-外键赋值"><a href="#4-1-外键赋值" class="headerlink" title="4.1.外键赋值"></a>4.1.外键赋值</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mall_models.OrderHasProduct.create(</div><div class="line">	<span class="keyword">order</span>=<span class="built_in">self</span>.db_model,</div><div class="line">	product=product.id,</div><div class="line">	<span class="params">...</span></div></pre></td></tr></table></figure>
<p>可以看到把<strong>外键实例</strong>或者<strong>外键实例的id</strong>都是可以的。</p>
<h3 id="4-2-涉及外键的查询"><a href="#4-2-涉及外键的查询" class="headerlink" title="4.2.涉及外键的查询"></a>4.2.涉及外键的查询</h3><h4 id="4-2-1-根据外键的主键查询"><a href="#4-2-1-根据外键的主键查询" class="headerlink" title="4.2.1 根据外键的主键查询"></a>4.2.1 根据外键的主键查询</h4><p>直接<code>OrderHasProduct.select().where(where(mall_models.Order.id=order.id).product_id=10086)</code></p>
<h4 id="4-2-2-根据外键的某字段查询（join外键）"><a href="#4-2-2-根据外键的某字段查询（join外键）" class="headerlink" title="4.2.2 根据外键的某字段查询（join外键）"></a>4.2.2 根据外键的某字段查询（join外键）</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="type">Rule</span>(<span class="title">models</span>.<span class="type">Model</span>):</span></div><div class="line">	owner = models.<span class="type">ForeignKey</span>(<span class="type">User</span>)</div><div class="line">	name = models.<span class="type">CharField</span>(<span class="title">max_length</span>=20, <span class="title">db_index</span>=<span class="type">True</span>) </div><div class="line">	valid = models.<span class="type">DecimalField</span>(<span class="title">max_digits</span>=65) </div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class</span> <span class="type">Card</span>(<span class="title">models</span>.<span class="type">Model</span>):</div><div class="line">	owner = models.<span class="type">ForeignKey</span>(<span class="type">User</span>)</div><div class="line">	rule = models.<span class="type">ForeignKey</span>(<span class="type">Rule</span>)</div></pre></td></tr></table></figure>
<p>Card有外键Rule。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">count = Card.select().join(wzcard_models.Rule).where(Card<span class="selector-class">.card_id</span><span class="selector-class">.in_</span>(ids),Rule<span class="selector-class">.valid</span> &gt;<span class="number">0</span>).count()</div></pre></td></tr></table></figure>
<p>的确很长，peewee不支持django风格的”__”（双下划线），所以就直街上join了，peewee默认使用INNER join。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;peewee使用指南&quot;&gt;&lt;a href=&quot;#peewee使用指南&quot; class=&quot;headerlink&quot; title=&quot;peewee使用指南&quot;&gt;&lt;/a&gt;peewee使用指南&lt;/h1&gt;&lt;p&gt;本系列文章基于peewee 2.6.4，同时会参照Django Orm做点比
    
    </summary>
    
    
      <category term="Python" scheme="http://ifchanged.io/tags/Python/"/>
    
      <category term="MySQL" scheme="http://ifchanged.io/tags/MySQL/"/>
    
      <category term="peewee" scheme="http://ifchanged.io/tags/peewee/"/>
    
  </entry>
  
  <entry>
    <title>emoji、Python、MySQL utf8mb4与UTF</title>
    <link href="http://ifchanged.io/2016/emoji%E3%80%81Python%E3%80%81MySQL%20utf8mb4%E4%B8%8EUTF/"/>
    <id>http://ifchanged.io/2016/emoji、Python、MySQL utf8mb4与UTF/</id>
    <published>2016-03-20T13:16:31.000Z</published>
    <updated>2017-01-08T14:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>编码、字符集是很大的内容，本文简单聊聊Python、MySQL中处理emoji这种特殊字符的问题。本文描述的Python是2.x版本，3.x情况可能有所不同</p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>如果向MySQL utf8的表中保存一个emoji字符，必然出错，因为emoji是4字节字符，而MySQL utf8只支持3字节字符。MySQL 5.5开始加入utf8mb4支持4字节字符，但是又带来了显示的问题，毕竟PC上无法正常显示emoji的，而且能显示的系统又各家有各家的样子。所以要么把emoji过滤掉、要么在显示时候做特殊处理。</p>
<h2 id="浅谈UTF"><a href="#浅谈UTF" class="headerlink" title="浅谈UTF"></a>浅谈UTF</h2><p>最常用的字符都在BMP（Basic Multilingual Plane, 基本多语言平面），范围是<strong>U+0000至U+FFFF</strong>。只有这些码位在UCS-2可用，也是MySQL UTF8可以存储的范围，其它字符存储在辅助平面。</p>
<p>其中从<strong>U+D800到U+DFFF</strong>之间的码位区段是永久保留不映射到Unicode字符。UTF-16就利用保留下来的0xD800-0xDFFF区段的码位来对辅助平面的字符的码位进行编码。Unicode规定这个范围不对应字符，但在使用UCS-2时会被用于映射某些字符。</p>
<h2 id="MySQL对4字节字符的支持"><a href="#MySQL对4字节字符的支持" class="headerlink" title="MySQL对4字节字符的支持"></a>MySQL对4字节字符的支持</h2><p>MySQL 5.5开始有了utf8mb4字符集，兼容utf8并且可以存储4字节字符，详见<a href="https://dev.mysql.com/doc/refman/5.5/en/charset-unicode-utf8mb4.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.5/en/charset-unicode-utf8mb4.html</a></p>
<h2 id="Python中的4字节字符"><a href="#Python中的4字节字符" class="headerlink" title="Python中的4字节字符"></a>Python中的4字节字符</h2><p>最开始的方案是直接识别4字节字符并直接过滤掉，3字节的范围是<code>\u0000-\uFFFF</code>，如果想直接判断一个字符是否在这个范围，<strong>可能</strong>会惊奇的发现一个字符被拆分成了两个字符，该字符的长度也是<strong>2</strong>。比如<code>\U0001f604</code>(笑脸表情，参见<a href="https://codepoints.net/U+1F604" target="_blank" rel="external">https://codepoints.net/U+1F604</a>)会被拆分成<code>\ud83d</code>和<code>\ude04</code>，<code>\U0001f604</code>展示了以一当二的能力。至于说可能，是因为这是由Python解释器编译时候编译选项是–enable-unicode=ucs4还是–enable-unicode=ucs2决定的，后者就是前文描述的情况。查看当前Python情况可以输出sys.maxunicode，得到65535就是ucs2，详见Python文档<a href="https://docs.python.org/2/library/sys.html#sys.maxunicode" target="_blank" rel="external">https://docs.python.org/2/library/sys.html#sys.maxunicode</a> 。ucs4下，4字节字符范围在<code>\U00010000-\U0010ffff</code>，usc2下拆分出的两个字符会在\uD800-\uDFFF范围。所以如果要过滤emoji或者其他特殊字符，可以根据此范围替换。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_invalid_str</span><span class="params">(text)</span>:</span></div><div class="line">	<span class="string">"""</span></div><div class="line">	过滤非BMP字符</div><div class="line">	"""</div><div class="line">	<span class="keyword">try</span>:</div><div class="line">		<span class="comment"># UCS-4</span></div><div class="line">		highpoints = re.compile(<span class="string">u'[\U00010000-\U0010ffff]'</span>)</div><div class="line">	<span class="keyword">except</span> re.error:</div><div class="line">		<span class="comment"># UCS-2</span></div><div class="line">		highpoints = re.compile(<span class="string">u'[\uD800-\uDBFF][\uDC00-\uDFFF]'</span>)</div><div class="line"></div><div class="line">	<span class="keyword">return</span> highpoints.sub(<span class="string">u'_'</span>, text)</div></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/UTF-16" target="_blank" rel="external">https://en.wikipedia.org/wiki/UTF-16</a></li>
<li><a href="https://docs.python.org/2/library/sys.html#sys.maxunicode" target="_blank" rel="external">https://docs.python.org/2/library/sys.html#sys.maxunicode</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.5/en/charset-unicode-utf8mb4.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.5/en/charset-unicode-utf8mb4.html</a></li>
<li><a href="http://stackoverflow.com/questions/26568722/remove-unicode-emoji-using-re-in-python" target="_blank" rel="external">http://stackoverflow.com/questions/26568722/remove-unicode-emoji-using-re-in-python</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编码、字符集是很大的内容，本文简单聊聊Python、MySQL中处理emoji这种特殊字符的问题。本文描述的Python是2.x版本，3.x情况可能有所不同&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title
    
    </summary>
    
    
      <category term="Python" scheme="http://ifchanged.io/tags/Python/"/>
    
      <category term="MySQL" scheme="http://ifchanged.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>git技巧</title>
    <link href="http://ifchanged.io/2015/git%E6%8A%80%E5%B7%A7/"/>
    <id>http://ifchanged.io/2015/git技巧/</id>
    <published>2015-11-23T02:44:27.000Z</published>
    <updated>2017-01-08T14:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>git技巧，不断更新中</p>
<ol>
<li><p>查找分支某个commit: </p>
<ol>
<li><code>git log|grep commitID</code></li>
<li><code>git branch --contains commitID</code> 可以配合grep指定分支</li>
</ol>
</li>
<li><p>比较分支不同的commit<br> <code>git rev-list A ^B</code>查找在B但不在A分支的commit</p>
</li>
<li><p>查找分支开发起点<br> <code>git rev-list A ^B|tail -1</code> B分支从A分支checkout出后的开发起点</p>
</li>
<li><p>查找不同commit数<br> <code>git rev-list A ^B --conut</code></p>
</li>
<li><p>强制更新本地分支到远程状态</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git fetch</div><div class="line">git <span class="built_in">reset</span> --hard <span class="built_in">origin</span>/master</div></pre></td></tr></table></figure>
</li>
</ol>
<p>或<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git fetch</div><div class="line">git checkout origin/<span class="keyword">master</span> <span class="title">-B</span> <span class="literal">master</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git技巧，不断更新中&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查找分支某个commit: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;git log|grep commitID&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch --contains commitID&lt;
    
    </summary>
    
    
      <category term="git" scheme="http://ifchanged.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git笔记-撤销与回滚</title>
    <link href="http://ifchanged.io/2015/git%E7%AC%94%E8%AE%B0-%E6%92%A4%E9%94%80%E4%B8%8E%E5%9B%9E%E6%BB%9A/"/>
    <id>http://ifchanged.io/2015/git笔记-撤销与回滚/</id>
    <published>2015-11-19T03:31:25.000Z</published>
    <updated>2017-01-08T14:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-撤销"><a href="#1-撤销" class="headerlink" title="1.撤销"></a>1.撤销</h2><h3 id="撤销文件修改"><a href="#撤销文件修改" class="headerlink" title="撤销文件修改"></a>撤销文件修改</h3><p>checkout以文件作为参数时会<strong>修改</strong>文件为指定版本的状态。</p>
<ul>
<li>撤销未暂存的文件：<code>git checkout hello.py</code>，<code>git checkout .</code>为所有未暂存文件</li>
<li>撤销未commit的文件：<code>git checkout HEAD hello.py</code></li>
<li>撤销已经commit的文件到指定版本，如e316e21：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git checkout e316e21 t1<span class="selector-class">.txt</span></div><div class="line">git add t1<span class="selector-class">.txt</span></div><div class="line">git commit -m <span class="string">'恢复t1.txt到e316e21'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注</strong>：以上撤销不会改写commit记录</p>
<h3 id="1-1-撤销commit（不改写commit记录）"><a href="#1-1-撤销commit（不改写commit记录）" class="headerlink" title="1.1 撤销commit（不改写commit记录）"></a>1.1 撤销commit（不改写commit记录）</h3><p>revert命令用新的commit来撤销修改，不改写提交记录。</p>
<ul>
<li>revert指定commit:<code>git revert e316e21</code></li>
<li><p>revert多个commit:<br>下文的大写字母带走commitID<br>方案1： 撤销多个commit并生成多个revert commit:<code>git revert A B C</code><br>方案2：撤销多个commit并生成一个revert commit：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">git</span> revert A B C --<span class="literal">no</span>-commit</div><div class="line">git commit -m <span class="string">'the commit message'</span></div></pre></td></tr></table></figure>
</li>
<li><p>revert指定范围：<code>git revert A..D</code></p>
</li>
</ul>
<h3 id="1-2-撤销commit（改写commit记录）"><a href="#1-2-撤销commit（改写commit记录）" class="headerlink" title="1.2 撤销commit（改写commit记录）"></a>1.2 撤销commit（改写commit记录）</h3><p>使用reset或者rebase可以改写记录，但是要注意的是一旦改写，commit将会消失，并且会和远程分支、他人的本地分支冲突，push时需要用参数<code>-f</code>强制提交。所以，除非你清楚的知道重写的作用以及对他人带来的影响，不要轻易重写记录。</p>
<h4 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h4><p><code>git rebase -i commitID</code> commitID只要撤销的commit之前的一个或者某个commit<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">pick a5997c9 <span class="number">1</span></div><div class="line">pick <span class="number">88</span>a1edf <span class="number">2</span></div><div class="line">pick dfa8d09 <span class="number">3</span></div><div class="line">pick <span class="number">57</span>d2c26 <span class="number">4</span></div><div class="line">pick ff3451d <span class="number">5</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta"># Rebase dfa8d09..ff3451d onto dfa8d09 (2 command(s))</span></div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta"># Commands:</span></div><div class="line"><span class="meta"># p, pick = use commit</span></div><div class="line"><span class="meta"># r, reword = use commit, but edit the commit message</span></div><div class="line"><span class="meta"># e, edit = use commit, but stop for amending</span></div><div class="line"><span class="meta"># s, squash = use commit, but meld into previous commit</span></div><div class="line"><span class="meta"># f, fixup = like "squash", but discard this commit's log message</span></div><div class="line"><span class="meta"># x, exec = run command (the rest of the line) using shell</span></div><div class="line"><span class="meta"># d, drop = remove commit</span></div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta"># These lines can be re-ordered; they are executed from top to bottom.</span></div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta"># If you remove a line here THAT COMMIT WILL BE LOST.</span></div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta"># However, if you remove everything, the rebase will be aborted.</span></div><div class="line"><span class="meta">#</span></div><div class="line"><span class="meta"># Note that empty commits are commented out</span></div></pre></td></tr></table></figure></p>
<p>参照git的提示，把要撤销的commit的action改为d，或者把正行删掉。</p>
<h4 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h4><p>如果这是要回滚到某个指定版本，如A，则直接<code>git reset A --hard</code>，如果要撤销的是提交记录中间的一个，则需要配合stash命令使用。<br>如有以下提交，要撤销其中的D提交，则：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A</div><div class="line">B</div><div class="line"><span class="keyword">C</span></div><div class="line"><span class="keyword">D</span></div><div class="line"><span class="keyword">E</span></div></pre></td></tr></table></figure></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">reset</span> <span class="comment">--soft D</span></div><div class="line">git stash</div><div class="line">git <span class="keyword">reset</span> <span class="comment">--hard E</span></div><div class="line">git stash pop</div><div class="line">git <span class="keyword">commit</span> -am 撤销D</div></pre></td></tr></table></figure>
<h3 id="1-3-撤销add"><a href="#1-3-撤销add" class="headerlink" title="1.3 撤销add"></a>1.3 撤销add</h3><p>当把某个文件add后，可以使用<code>git reset file_path</code>撤销add。</p>
<h3 id="1-4-撤销最近一次commit"><a href="#1-4-撤销最近一次commit" class="headerlink" title="1.4 撤销最近一次commit"></a>1.4 撤销最近一次commit</h3><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 –amend 选项的提交命令尝试重新提交：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git <span class="keyword">commit</span> -m <span class="string">'initial commit'</span></div><div class="line">$ git <span class="keyword">add</span> forgotten_file</div><div class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend</span></div></pre></td></tr></table></figure></p>
<p>第二次提交将会覆盖之前的提交。</p>
<h3 id="撤销（删除）未追踪的文件"><a href="#撤销（删除）未追踪的文件" class="headerlink" title="撤销（删除）未追踪的文件"></a>撤销（删除）未追踪的文件</h3><p><code>git clean -fdx</code></p>
<h2 id="2-版本回滚"><a href="#2-版本回滚" class="headerlink" title="2.版本回滚"></a>2.版本回滚</h2><p>版本回滚指把当前的分支切换到某个指定版本，具体而言是切换到某个commit或者tag，和上文提到的撤销类似，当从head开始撤销连续的若干commit就可达到回滚的效果。版本回滚是分支的角度，撤销是某个文件或者commit的角度。</p>
<p>如有以下提交，：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A</div><div class="line">B</div><div class="line"><span class="keyword">C</span></div><div class="line"><span class="keyword">D</span></div><div class="line"><span class="keyword">E</span></div></pre></td></tr></table></figure></p>
<p>要回滚<strong>到D</strong>提交，有以下方法。</p>
<h3 id="2-1-revert回滚（不改写commit记录）"><a href="#2-1-revert回滚（不改写commit记录）" class="headerlink" title="2.1 revert回滚（不改写commit记录）"></a>2.1 revert回滚（不改写commit记录）</h3><p>revert回滚是唯一可以不修改commit记录的回滚方式，但是会产生一次revert commit。方法是上文讲到的<strong>revert多个commit</strong>。此时，要把D之后的提交全部revert。则：<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="title">git</span></span> revert D..HEAD --<span class="keyword">no</span>-commit</div><div class="line">git commit -am <span class="string">'revert to D'</span></div></pre></td></tr></table></figure></p>
<p>当不清楚范围是否制定正确的时候，可以使用<code>git revert D..HEAD</code>，与上面命令的区别是没有–no-commit参数，也不用最好再commit，git会自动的revert每一个commit并每个commit生成一个revert commit，这样就能看到revert了哪些commit。</p>
<h3 id="2-2-reset回滚（改写commit记录）"><a href="#2-2-reset回滚（改写commit记录）" class="headerlink" title="2.2 reset回滚（改写commit记录）"></a>2.2 reset回滚（改写commit记录）</h3><p>和撤销中的用法类似：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">reset</span> <span class="comment">--hard D</span></div></pre></td></tr></table></figure></p>
<h3 id="2-2-checkout回滚（改写提交记录）"><a href="#2-2-checkout回滚（改写提交记录）" class="headerlink" title="2.2 checkout回滚（改写提交记录）"></a>2.2 checkout回滚（改写提交记录）</h3><p>checkout有三个目标，checkout文件是撤销中提到的改写文件，checkout分支是常用的切换分支，checkout commit就会切换到该commit，结合切换分支就可以达到回滚分支的作用。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">git checkout D</span></div></pre></td></tr></table></figure></p>
<p>此时git会给出提示:</p>
<blockquote>
<p>You are in ‘detached HEAD’ state. You can look around, make experimental<br>changes and commit them, and you can discard any commits you make in this<br>state without impacting any branches by performing another checkout.</p>
</blockquote>
<p>简而言之，我们现在不在分支上，在’detached HEAD’ state（游离状态），当前的代码在commit D发生时的状态，<strong>此时的任何更改不会影响到任何分支</strong>。我们可以不回滚代码就可让代码处于之前的某个提交，查看之前的代码或者做些实验。</p>
<p>从游离状态退出的方法是checkout到某个分支，你如<code>git checkout master</code>。而如果用创建分支的方法checkout -b <branch_name>就可以从当前创建分支，结合强制创建分支的参数-B，checkout回滚分支可以概括为：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">git</span> checkout -<span class="keyword">B </span>test <span class="number">6</span>a26980</div></pre></td></tr></table></figure></branch_name></p>
<p>其中test是当前的分支名，6a26980是要回滚到的版本。</p>
<h3 id="2-3-本地分支回滚到远程分支"><a href="#2-3-本地分支回滚到远程分支" class="headerlink" title="2.3 本地分支回滚到远程分支"></a>2.3 本地分支回滚到远程分支</h3><p>当本地分支被改的乱七八糟时，你可能会想到重新拉取远程分支，一切重来。比较容易理解的方式可能是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git checkout -B master 随便切换个别的分支</div><div class="line">git branch -D <span class="built_in">test</span> 把糟糕的本地分支删掉</div><div class="line">git fetch 更新下远程引用分支</div><div class="line">git checkout <span class="built_in">test</span> 重新checkout <span class="built_in">test</span>分支</div></pre></td></tr></table></figure></p>
<p>这样子非常繁琐。有两个便捷的命令：<br><code>git checkout origin/test -B test</code>或者<code>git reset origin/test --hard</code>,当然，执行前别忘了<code>git fetch</code>更新。</p>
<h2 id="3-reflog"><a href="#3-reflog" class="headerlink" title="3.reflog"></a>3.reflog</h2><p>reflog记录了<strong>本地仓库</strong>的指针移动,使用<code>git reflog</code>查看,<code>git reflog --relative-date</code>可以查看到时间。，如下：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">b37132b HEAD@&#123;<span class="number">16</span> minutes ago&#125;: <span class="string">reset:</span> moving to origin/master</div><div class="line"><span class="number">94</span>a99ad HEAD@&#123;<span class="number">16</span> minutes ago&#125;: <span class="string">commit:</span> s</div><div class="line">b37132b HEAD@&#123;<span class="number">21</span> minutes ago&#125;: <span class="string">clone:</span> from git<span class="meta">@github</span>.<span class="string">com:</span>ladder1984/updateHosts</div></pre></td></tr></table></figure></p>
<p>上面的日志显示进行了reset操作，如果想恢复到reset之前的状态，可以使用<code>git reset 94a99ad --hard</code>命令。注意，reflog查看到的ID也是可以checkout命令的，所以也可以使用<code>git checkout 94a99ad -B master</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-撤销&quot;&gt;&lt;a href=&quot;#1-撤销&quot; class=&quot;headerlink&quot; title=&quot;1.撤销&quot;&gt;&lt;/a&gt;1.撤销&lt;/h2&gt;&lt;h3 id=&quot;撤销文件修改&quot;&gt;&lt;a href=&quot;#撤销文件修改&quot; class=&quot;headerlink&quot; title=&quot;撤销文件修
    
    </summary>
    
    
      <category term="git" scheme="http://ifchanged.io/tags/git/"/>
    
      <category term="git笔记" scheme="http://ifchanged.io/tags/git%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>git rebase实践</title>
    <link href="http://ifchanged.io/2015/git-rebase%E5%AE%9E%E8%B7%B5/"/>
    <id>http://ifchanged.io/2015/git-rebase实践/</id>
    <published>2015-10-28T11:54:15.000Z</published>
    <updated>2017-01-08T14:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>同一个分支有三种表现形式</p>
<ol>
<li>远程分支</li>
<li>远程引用分支 origin/master</li>
<li>本地分支    master</li>
</ol>
<p>fetch会更新远程引用分支，本地分支merge远程引用分支之后才会更新本地分支。</p>
<h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><p>pull实际执行了<code>git fetch</code>和<code>git merge FETCH_HEAD</code>两条指令</p>
<h3 id="rebase的意义"><a href="#rebase的意义" class="headerlink" title="rebase的意义"></a>rebase的意义</h3><p>rebase的作用是重写提交记录。</p>
<ul>
<li><p>rebase优点：</p>
<ol>
<li>合并commit（与前分支rebase）</li>
<li>避免merge commit（与master rebase）</li>
<li>重写提交记录</li>
</ol>
</li>
<li><p>rebase缺点：</p>
</li>
</ul>
<ol>
<li>操作不慎会丢失commit</li>
<li>影响不到的冲突（由merge commit引起）</li>
</ol>
<p>在操作不熟练时，可以先备份分支<code>checkout -b bak_xxx</code>。</p>
<p>merge+revert的方式可以保证代码的安全性，但提交记录混乱。rebase+reset的方式能够保证提交记录的清晰。</p>
<h2 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h2><h3 id="创建新的分支"><a href="#创建新的分支" class="headerlink" title="创建新的分支"></a>创建新的分支</h3><p>开始需求时，需要建立一个新分支，并把它推送到远程仓库。新建分支的方法多种多样，唯一的原则是从master新建分支。</p>
<ol>
<li>更新master<ol>
<li><code>git checkout master</code></li>
<li><code>git pull</code></li>
</ol>
</li>
<li>从master创建feature分支：<br> <code>git checkout master -b test</code> 或 <code>git checkout origin/master -b</code></li>
<li>推送分支当远程<br>  <code>git push -u origin test:test</code> 本地分支名在前<br> -u是–set-upstream-to 的简写，设置追踪分支。</li>
</ol>
<h3 id="拉取分支"><a href="#拉取分支" class="headerlink" title="拉取分支"></a>拉取分支</h3><p>其他人在此分支协作时的获取。<br>    <code>git checkout --track origin/test</code></p>
<h2 id="更新分支"><a href="#更新分支" class="headerlink" title="更新分支"></a>更新分支</h2><h3 id="从master更新"><a href="#从master更新" class="headerlink" title="从master更新"></a>从master更新</h3><ol>
<li><strong>方案1</strong><ol>
<li><code>git checkout master</code></li>
<li><code>git pull</code></li>
<li><code>git checkout test</code></li>
<li><code>git rebase master</code></li>
</ol>
</li>
<li><strong>方案2（推荐）</strong><br> <code>git pull --rebase origin master</code><br> <strong>注意：</strong>此种方法不会更新本地master分支</li>
</ol>
<h3 id="从test更新"><a href="#从test更新" class="headerlink" title="从test更新"></a>从test更新</h3><p><code>git pull --rebase</code><br><strong>注意</strong>：需要先设置跟踪分支</p>
<h2 id="完成后合并到master"><a href="#完成后合并到master" class="headerlink" title="完成后合并到master"></a>完成后合并到master</h2><p>在test分支开发<strong>完成</strong>后，需要通过rebase合并commit，此时rebase的目标不再是分支，而是在test分支中的commit。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li>从master更新test分支，方法见上文</li>
<li>寻找rebase点，使用<code>git log</code>查看test分支中最后一个commit，如<br>66fc050b </li>
<li><code>rebase -i 66fc050b</code>开始rebase</li>
</ol>
<h3 id="交互式rebase"><a href="#交互式rebase" class="headerlink" title="交互式rebase"></a>交互式rebase</h3><p>在执行rebase -i命令会打开sublime编辑器<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">pick <span class="number">66</span>fc050 Test:git pull --rebase origin <span class="keyword">master</span></div><div class="line"><span class="title">pick</span> a8b6d2f <span class="number">2</span></div><div class="line">pick c2c1903 xsas</div><div class="line"></div><div class="line"><span class="comment"># Rebase 749e319..c2c1903 onto 749e319 (3 command(s))</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Commands:</span></div><div class="line"><span class="comment"># p, pick = use commit</span></div><div class="line"><span class="comment"># r, reword = use commit, but edit the commit message</span></div><div class="line"><span class="comment"># e, edit = use commit, but stop for amending</span></div><div class="line"><span class="comment"># s, squash = use commit, but meld into previous commit</span></div><div class="line"><span class="comment"># f, fixup = like "squash", but discard this commit's log message</span></div><div class="line"><span class="comment"># x, exec = run command (the rest of the line) using shell</span></div><div class="line"><span class="comment"># d, drop = remove commit</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># However, if you remove everything, the rebase will be aborted.</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Note that empty commits are commented out</span></div></pre></td></tr></table></figure></p>
<p>内容以<code>动作 commitID commit信息</code>的形式展现，66fc050、a8b6d2f、c2c1903就是三次提交，如果需要合并三次提交，修改成<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pick <span class="number">66</span>fc050 Test:git pull --rebase origin <span class="keyword">master</span></div><div class="line"><span class="title">f</span> a8b6d2f <span class="number">2</span></div><div class="line">f c2c1903 xsas</div></pre></td></tr></table></figure></p>
<p>然后保存文件并退出sublime。</p>
<p>如果rebase过程中遇到冲突，解决完冲突后执行<code>git rebase --continue</code>，需要注意的是，即使强制关闭控制台，依然会处于rebase状态，需要执行<code>git rebase --abort</code>取消rebase，版本库会会滚刀rebase之前的状态。或者执行<code>git rebase --edit-todo</code>重新打开rebase文件。</p>
<p>如果产生冲突，rebase会逐个释放冲突，处理完冲突后，执行<code>git rebase --continue</code>继续。</p>
<h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>test分支经过rebase后，显然已经和远程分支冲突了，<br>需要强制提交:<br><code>git push -f</code><br>或者先删除远程分支:</p>
<ol>
<li><code>git push origin --delete test</code></li>
<li><code>git push origin test:test</code></li>
</ol>
<h3 id="管理员合并分支"><a href="#管理员合并分支" class="headerlink" title="管理员合并分支"></a>管理员合并分支</h3><p>最终由管理员把test分支合并到master，需要注意的是合并前需要把test分支从master分支rebase更新，避免merge commit。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="使用Sublime-Text作为外部文本编辑器"><a href="#使用Sublime-Text作为外部文本编辑器" class="headerlink" title="使用Sublime Text作为外部文本编辑器"></a>使用Sublime Text作为外部文本编辑器</h3><p>对git进行设置通常使用git config命令或者直接编辑.config文件</p>
<p><code>git config --global core.editor &quot;&#39;C:/Program Files/Sublime Text 2/sublime_text.exe&#39; -w&quot;</code><br>或<br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="name">core</span>]</div><div class="line">	editor = <span class="symbol">'C:</span>\\Program Files\\Sublime Text <span class="number">2</span>\\sublime_text.exe' -w</div></pre></td></tr></table></figure></p>
<h3 id="rebase取代merge"><a href="#rebase取代merge" class="headerlink" title="rebase取代merge"></a>rebase取代merge</h3><p><code>git config --global branch.autosetuprebase always</code><br>或<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">[branch]</span></div><div class="line">	autosetuprebase = always</div></pre></td></tr></table></figure></p>
<h3 id="reset在合并提交中的应用"><a href="#reset在合并提交中的应用" class="headerlink" title="reset在合并提交中的应用"></a>reset在合并提交中的应用</h3><p><code>git reset commitId</code> commitId 的位置同rebase，reset会撤销提交，一切回滚到<code>git add</code>和<code>git commit</code>之前的状态，所以我们可以把所有修改一次commit，达到合并commit的作用。</p>
<p>需要注意的是，reset后，提交人信息和提交信息(commit msg)都会丢失。</p>
<h3 id="git-hooks-go"><a href="#git-hooks-go" class="headerlink" title="git_hooks_go"></a>git_hooks_go</h3><p>通过git hooks的方式为提交信息添加用户名、分支名等信息，方便rebase。<br>运行git_hooks_go目录下的install.py安装。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>从master创建分支</li>
<li>使用rebase更新</li>
<li>使用rebase -i 合并commit</li>
<li>管理员合并分支</li>
</ol>
<p>更新git：<br><a href="http://git-scm.com/download/" target="_blank" rel="external">http://git-scm.com/download/</a></p>
<p>git文档：</p>
<ol>
<li><a href="http://git-scm.com/book/zh/v2" target="_blank" rel="external">http://git-scm.com/book/zh/v2</a></li>
<li><a href="https://www.atlassian.com/git/tutorials/" target="_blank" rel="external">https://www.atlassian.com/git/tutorials/</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备知识&quot;&gt;&lt;a href=&quot;#准备知识&quot; class=&quot;headerlink&quot; title=&quot;准备知识&quot;&gt;&lt;/a&gt;准备知识&lt;/h2&gt;&lt;h3 id=&quot;分支&quot;&gt;&lt;a href=&quot;#分支&quot; class=&quot;headerlink&quot; title=&quot;分支&quot;&gt;&lt;/a&gt;分支&lt;/h
    
    </summary>
    
    
      <category term="git" scheme="http://ifchanged.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>使用页面可见性API Visibility</title>
    <link href="http://ifchanged.io/2015/%E4%BD%BF%E7%94%A8%E9%A1%B5%E9%9D%A2%E5%8F%AF%E8%A7%81%E6%80%A7API-Visibility/"/>
    <id>http://ifchanged.io/2015/使用页面可见性API-Visibility/</id>
    <published>2015-09-25T10:38:43.000Z</published>
    <updated>2017-01-08T14:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>可见性API的好处是判断当前页面是否可见，并基于此执行不同的操作，通常可以节省不少资源，比如轮询，比如视频播放。</p>
<p>可见性API包括两个属性<strong>document.hidden</strong>、<strong>document.visibilityState</strong>和一个事件<strong>visibilitychange</strong>。</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>HTML5扩展了document的接口，增加了<code>hidden</code>和<code>visibilityState</code>两个属性，它们的含义也比较接近。</p>
<p><code>hidden</code>返回一个布尔值，表示页面是否完全不可见。<code>visibilityState</code>表示可见状态，返回一个字符串，可能的返回值是<code>visible</code>、<code>hidden</code>、<code>prerender</code>、<code>uploaded</code>，具体含义可以看MDN的介绍<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API" target="_blank" rel="external">使用页面可见性API</a></p>
<p><code>visibilitychange</code>事件当页面可见性改变的时候会触发。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>结合两个属性和事件，可以很好的根据页面可见性进行一些操作，比如<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"visibilitychange"</span>, func, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="built_in">document</span>.visibilityState == <span class="string">'visible'</span>)&#123;  </div><div class="line">    <span class="comment">//do sth.</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">document</span>.visibilityState == <span class="string">'hidden'</span>)&#123;</div><div class="line">    <span class="comment">//do sth.</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参考文档：</p>
<ul>
<li><a href="http://www.w3.org/TR/page-visibility/" target="_blank" rel="external">http://www.w3.org/TR/page-visibility/</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Events/visibilitychange" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/Events/visibilitychange</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API</a></li>
<li><a href="http://blogs.msdn.com/b/ie/archive/2011/07/08/using-pc-hardware-more-efficiently-in-html5-new-web-performance-apis-part-2.aspx" target="_blank" rel="external">http://blogs.msdn.com/b/ie/archive/2011/07/08/using-pc-hardware-more-efficiently-in-html5-new-web-performance-apis-part-2.aspx</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;可见性API的好处是判断当前页面是否可见，并基于此执行不同的操作，通常可以节省不少资源，比如轮询，比如视频播放。&lt;/p&gt;
&lt;p&gt;可见性API
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://ifchanged.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>MySQL时间精确度问题</title>
    <link href="http://ifchanged.io/2015/MySQL%E6%97%B6%E9%97%B4%E7%B2%BE%E7%A1%AE%E5%BA%A6%E9%97%AE%E9%A2%98/"/>
    <id>http://ifchanged.io/2015/MySQL时间精确度问题/</id>
    <published>2015-09-19T16:17:59.000Z</published>
    <updated>2017-01-08T14:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>在项目最近的自动化测试中，会出现一个随机出现的报错，表现为根据生成时间排序的item有时候会和预期不符。经确认，该问题是由MySQL中默认情况下时间只存储到秒引起的，所以，在自动化测试服务器快速生成item时，可能出现先后创建的项目记录为同一个生成时间，在相关页面以生成时间排序时顺序可能和预期不符。</p>
<h2 id="问题探究"><a href="#问题探究" class="headerlink" title="问题探究"></a>问题探究</h2><p>在MySQL默认情况下， 时间只会精确到秒。在MySQL 5.6.4之前，时间只能精确保存到秒，在MySQL 5.6.4之后以分数秒（Fractional Seconds）的形式保存更精确的时间，格式形如’2010-12-10 14:12:09.019473’。</p>
<h3 id="fractional-seconds的使用"><a href="#fractional-seconds的使用" class="headerlink" title="fractional seconds的使用"></a>fractional seconds的使用</h3><p>截止到MySQL 5.7，时间的最大精确度是微妙（microsecond）。使用fractional seconds需要使用语法<code>type_name(fsp)</code>,type_name可为TIME, DATETIME, 和TIMESTAMP类型，fsp表示精度，取值范围是0-6，6时即表示微妙。例如<code>CREATE TABLE t1 (t TIME(3), dt DATETIME(6));</code>。以下为MySQL官方文档中的示例：</p>
<pre><code>mysql&gt; CREATE TABLE fractest( c1 TIME(2), c2 DATETIME(2), c3 TIMESTAMP(2) );
Query OK, 0 rows affected (0.33 sec)

mysql&gt; INSERT INTO fractest VALUES 
     &gt; (&apos;17:51:04.777&apos;, &apos;2014-09-08 17:51:04.777&apos;, &apos;2014-09-08 17:51:04.777&apos;);
Query OK, 1 row affected (0.03 sec)

mysql&gt; SELECT * FROM fractest;
+-------------+------------------------+------------------------+
| c1          | c2                     | c3                     |
+-------------+------------------------+------------------------+
| 17:51:04.78 | 2014-09-08 17:51:04.78 | 2014-09-08 17:51:04.78 |
+-------------+------------------------+------------------------+
1 row in set (0.00 sec)
</code></pre><p>更多信息，参考MySQL官方文档：<a href="http://dev.mysql.com/doc/refman/5.6/en/fractional-seconds.html" target="_blank" rel="external">Fractional Seconds in Time Values</a></p>
<p>至于fractional second为什么直到MySQL 5.6.4才支持以及需要手动指定精确度，个人猜测是多数情况下不需要如此高的精确度，以及高精确度带来的性能问题。</p>
<h3 id="Django中的支持"><a href="#Django中的支持" class="headerlink" title="Django中的支持"></a>Django中的支持</h3><p>似乎到了Django 1.8才对fractional seconds进行支持，创建model时可以使用<code>DATETIME(6)</code>,参见Django 1.8的<a href="https://docs.djangoproject.com/en/dev/releases/1.8/#database-backends" target="_blank" rel="external">release notes</a>和<a href="https://docs.djangoproject.com/en/dev/ref/databases/#mysql-fractional-seconds" target="_blank" rel="external">文档</a>。<br>需要注意的是：</p>
<ol>
<li>使用fractional seconds的最低版本为MySQL 5.6.4和MySQLdb 1.2.5。</li>
<li>Django不会更新已有的数据库，需要执行SQL语句进行修改数据库，或执行Data Migrations操作</li>
<li>对于早期版本，是有hack方案的，参见stackoverflow上的问题<a href="http://stackoverflow.com/questions/17846504/how-to-create-a-django-custom-field-to-store-mysql-datetime6-and-enable-fracti" target="_blank" rel="external">How to create a Django custom Field to store MYSQL DATETIME(6) and enable fractional seconds (milliseconds and or microseconds) in Django/MySQL?</a></li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>显然，在业务需求精确到秒即可满足的情况，为了自动化测试而更改已经部署的MySQL、Django版本及代码是得不偿失的。所以最终较好的解决方案是在自动化测试的代码中把item的生成时间根据生成次序进行二次处理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h2&gt;&lt;p&gt;在项目最近的自动化测试中，会出现一个随机出现的报错，表现为根据生成时间排序的item有时候会和预期不符。经确认，该问题是由M
    
    </summary>
    
    
      <category term="Django" scheme="http://ifchanged.io/tags/Django/"/>
    
      <category term="MySQL" scheme="http://ifchanged.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Python模拟登录京东</title>
    <link href="http://ifchanged.io/2015/Python%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%E4%BA%AC%E4%B8%9C/"/>
    <id>http://ifchanged.io/2015/Python模拟登录京东/</id>
    <published>2015-09-13T15:16:01.000Z</published>
    <updated>2017-01-08T14:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模拟登录的方法"><a href="#模拟登录的方法" class="headerlink" title="模拟登录的方法"></a>模拟登录的方法</h2><p>真实用户在登录网站时，是在登录页面填写自己的账号、密码信息，并点击登录按钮。从实现的角度上讲，实际上是执行了一个Http Post请求，向网站服务器提交数据。模拟登录就是通过程序对这种行为进行模拟，所以一是要准备账号、密码等信息，二是要像用户一样进行post。</p>
<p>但是，通常网站都会限制程序的模拟登录，通常的方法也就是在上面提到的两点上进行检测。一是增加要提交的校验信息，二是检测post的行为。</p>
<p>本文介绍使用Python进行模拟登录京东网，使用PyQuery来捕捉京东增加的校验信息，用requests执行post请求。</p>
<h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><p>首先找到京东的登录页面<a href="https://passport.jd.com/new/login.aspx" target="_blank" rel="external">https://passport.jd.com/new/login.aspx</a> ,随便提交一次，发现post的地址是<a href="https://passport.jd.com/uc/loginService" target="_blank" rel="external">https://passport.jd.com/uc/loginService</a> ，以及post数据为：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">uuid:</span><span class="number">53</span>c85802-XXX-ebdd952dda93</div><div class="line"><span class="symbol">machineNet:</span></div><div class="line"><span class="symbol">machineCpu:</span></div><div class="line"><span class="symbol">machineDisk:</span></div><div class="line"><span class="symbol">SGIARTgLfH:</span>dJGep</div><div class="line"><span class="symbol">loginname:</span>XXXX</div><div class="line"><span class="symbol">nloginpwd:</span>XXX</div><div class="line"><span class="symbol">loginpwd:</span>XXX</div><div class="line"><span class="symbol">chkRememberMe:</span>on</div><div class="line"><span class="symbol">authcode:</span></div></pre></td></tr></table></figure></p>
<p>其中,<code>loginname</code>是用户名，<code>nloginpwd</code>和<code>loginpwd</code>都是密码，<code>uuid</code>、loginname上面的一组数据(本例中为SGIARTgLfH:dJGep)三者都是用于验证登录的随机字符串。<code>authcode</code>为验证码,<code>chkRememberMe</code>为是否自动登录。其他的项留空。</p>
<p>所以，重要的是获取uuid和那组随机数据。这些数据都在登录页面<a href="https://passport.jd.com/new/login.aspx" target="_blank" rel="external">https://passport.jd.com/new/login.aspx</a> 中。检查该页面源码，这些数据都在<form id="formlogin">表格中，使用pyquery进行选择，代码为：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">uuid = <span class="built_in">d</span>(<span class="string">"#uuid"</span>).attr(<span class="string">"value"</span>)</div><div class="line">left = <span class="built_in">d</span>('#formlogin <span class="keyword">input</span>[<span class="keyword">type</span>=<span class="string">"hidden"</span>]:<span class="keyword">eq</span>(4)').attr(<span class="string">"name"</span>)</div><div class="line">right = <span class="built_in">d</span>('#formlogin <span class="keyword">input</span>[<span class="keyword">type</span>=<span class="string">"hidden"</span>]:<span class="keyword">eq</span>(4)').attr(<span class="string">"value"</span>)</div></pre></td></tr></table></figure></form></p>
<p>另外一个重要数据是验证码，在多次尝试登录或者其他京东不喜欢的情况下，会要求填写验证码。同样使用pyquery查找验证码，代码为：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">auth_img_url</span> = d(<span class="string">'#JD_Verification1'</span>).attr(<span class="string">"src2"</span>)</div></pre></td></tr></table></figure></p>
<p>然后下载验证码，在不是很频繁登录的情况下，手动填写就够了。</p>
<p>需要<strong>注意</strong>的是，京东的网页随时可能修改，post的数据和数据的来源都要根据实际情况确定。</p>
<h2 id="进行登录"><a href="#进行登录" class="headerlink" title="进行登录"></a>进行登录</h2><p>登录操作使用requests，需要注意的是，要使用requests中的Session，首先创建<code>s = requests.Session()</code>，然后使用<code>s.post</code>和<code>s.get</code>进行操作。<code>s.post(login_post_url, data=login_data)</code>即可。返回<code>({&quot;success&quot;:&quot;http://www.jd.com&quot;})</code>表示登录成功，可以使用s会话进行后续操作。</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>完整代码如下：</p>
<script src="//gist.github.com/2a1231184de59a725f64.js?file=login_jingdong.py"></script>
<p>或访问gist查看<a href="https://gist.github.com/ladder1984/2a1231184de59a725f64" target="_blank" rel="external">https://gist.github.com/ladder1984/2a1231184de59a725f64</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模拟登录的方法&quot;&gt;&lt;a href=&quot;#模拟登录的方法&quot; class=&quot;headerlink&quot; title=&quot;模拟登录的方法&quot;&gt;&lt;/a&gt;模拟登录的方法&lt;/h2&gt;&lt;p&gt;真实用户在登录网站时，是在登录页面填写自己的账号、密码信息，并点击登录按钮。从实现的角度上讲，实际上
    
    </summary>
    
    
      <category term="Python" scheme="http://ifchanged.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>第2章 词法分析——The Python Language Reference阅读笔记</title>
    <link href="http://ifchanged.io/2015/%E7%AC%AC2%E7%AB%A0%20%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E2%80%94%E2%80%94The%20Python%20Language%20Reference%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://ifchanged.io/2015/第2章 词法分析——The Python Language Reference阅读笔记/</id>
    <published>2015-04-15T15:08:51.000Z</published>
    <updated>2017-01-08T14:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-词法分析（Lexical-analysis）"><a href="#第二章-词法分析（Lexical-analysis）" class="headerlink" title="第二章 词法分析（Lexical analysis）"></a>第二章 词法分析（Lexical analysis）</h1><p>一个 Python 程序由 <strong>解析器</strong>(parser) 读入, 输入解析器的是由 <strong>词法分析器</strong>(lexical analyzer) 生成的 <strong>语言符号</strong>(token) 流. 本章讨论词法分析器是如何把文件割成若干语言符号的.</p>
<p>Python使用7位ASCII字符作为程序文本（注意：Python3使用Unicode）。</p>
<h2 id="2-1-行结构"><a href="#2-1-行结构" class="headerlink" title="2.1.行结构"></a>2.1.行结构</h2><p>Python程序由逻辑行组成。</p>
<h3 id="2-1-1-逻辑行"><a href="#2-1-1-逻辑行" class="headerlink" title="2.1.1.逻辑行"></a>2.1.1.逻辑行</h3><p>逻辑行的结尾以“换行”（NEWLINE）为标志，语句不能出现在多个逻辑行，除非语法支持（例如符合语句，复合语句在第七章详解）。逻辑行由一个或多个显/隐式连接的物理行。</p>
<p>文档中没有明确给出“NEWLINE”的定义，我的理解是逻辑行形式上等同于组成它的物理行，所以物理行的结束也就是逻辑行的结束。</p>
<h3 id="2-1-2-物理行"><a href="#2-1-2-物理行" class="headerlink" title="2.1.2.物理行"></a>2.1.2.物理行</h3><p>物理行以end-of-line（EOL）结束，这个EOL在每个平台不同。</p>
<blockquote>
<p>以ASCII为基础的或相容的字元集使用分别LF（Line feed，0Ah）或CR（Carriage Return，0Dh）或CR+LF；下面列出各系统换行字元编码的列表</p>
<p>  <strong>LF</strong>：在Unix或Unix相容系统（GNU/Linux，AIX，Xenix，Mac OS X，…）、BeOS、Amiga、RISC OS<br>  <strong>CR+LF</strong>：MS-DOS、微软视窗操作系统（Microsoft Windows）、大部分非Unix的系统<br>  <strong>CR</strong>：Apple II家族，Mac OS至版本9<br>  <a href="http://zh.wikipedia.org/zh-cn/%E6%8F%9B%E8%A1%8C" target="_blank" rel="external">换行 - 维基百科</a></p>
</blockquote>
<p>物理行等同于视觉上看到的行，这个是考验编辑器的事情。</p>
<h3 id="2-1-3-注释"><a href="#2-1-3-注释" class="headerlink" title="2.1.3.注释"></a>2.1.3.注释</h3><p><strong>comment</strong>是以#开头的物理行，会被解释器忽略。文档中并没有提到另一种注释，三个引号(“””)包围的东西，<strong>文档注释（doc string）</strong>。如：</p>
<pre>
def foo():
    """文档注释"""
    return None 
print(foo.__doc__)  
help(foo)
</pre>

<h3 id="2-1-4-编码声明"><a href="#2-1-4-编码声明" class="headerlink" title="2.1.4.编码声明"></a>2.1.4.编码声明</h3><p>声明编码，源文件中第一行或者第二行匹配正则表达式<code>coding[=:]\s*([-\w.]+)</code>的注释，通常写成 # -<em>- coding: utf-8 -</em>- 或者coding=utf8。当然声明的编码Python得认识，通常声明成utf-8就好。</p>
<p><strong>编码设置会用于整个词法分析过程, 包括字符串字面值, 注释和标识符。</strong></p>
<p>另外，Python还能识别UTF-8 byte-order mark (‘\xef\xbb\xbf’)，也就是微软的恶趣味BOM。通常自己编写的文件最好避免出现BOM，读取文本文件时候也要注意BOM。</p>
<h3 id="2-1-5-显式行连接"><a href="#2-1-5-显式行连接" class="headerlink" title="2.1.5.显式行连接"></a>2.1.5.显式行连接</h3><p>行连接是为了把多个物理行连接成一个逻辑行，显式即是通过反斜杠（\,backslashe）。要注意的反斜杠后面不能有注释。</p>
<h3 id="2-1-6-隐式行连接"><a href="#2-1-6-隐式行连接" class="headerlink" title="2.1.6.隐式行连接"></a>2.1.6.隐式行连接</h3><p>圆括号()、方括号[]、花括号{}中多个物理行的内容不需要显式连接，并且可以添加注释。例如：</p>
<pre>
month_names = ['Januari', 'Februari', 'Maart',  # These are the
   'April',   'Mei',  'Juni',   # Dutch names
   'Juli','Augustus', 'September',  # for the months
   'Oktober', 'November', 'December']   # of the year
</pre>

<h3 id="2-1-7-空行"><a href="#2-1-7-空行" class="headerlink" title="2.1.7.空行"></a>2.1.7.空行</h3><p>简单来说，空的行在解析时会被忽略。所谓空行就是只有空格、制表符、进纸符和注释的逻辑行。在交互时，空行根据具体实现而定。</p>
<h3 id="2-1-8-缩进"><a href="#2-1-8-缩进" class="headerlink" title="2.1.8.缩进"></a>2.1.8.缩进</h3><p>缩进用来区分语句是Python最明显的特色，缩进可以使用制表符（tab）或者空格，在解析时候tab会被先转换成空格，推荐使用四个空格的方式。</p>
<p>另外，用<strong>分号(;)</strong>将多个语句写在同一行上，语句之间用分号隔开，而这些语句也不能在这行开始一个新的代码块。例如：<code>a=1;a=2</code>。不过，不推荐这样做，也基本没见过这样写的Python代码。</p>
<p>Python用栈来控制缩进，详情看官方文档：<a href="https://docs.python.org/2/reference/lexical_analysis.html#indentation" title="Indentation" target="_blank" rel="external">Indentation</a></p>
<h3 id="2-1-9-语言符号间的空白符"><a href="#2-1-9-语言符号间的空白符" class="headerlink" title="2.1.9.语言符号间的空白符"></a>2.1.9.语言符号间的空白符</h3><p>除了在行首、字符串中这样的特殊位置，空白符的作用就是把标记分号，如把变量<strong>ab</strong>分隔成<strong>a b</strong>两个变量。</p>
<h2 id="2-2-其他记号"><a href="#2-2-其他记号" class="headerlink" title="2.2.其他记号"></a>2.2.其他记号</h2><p>除了换行（NEWLINE）、缩进（INDENT）、DEDENT（啥？），语言记号包括：标识符、关键字、字面值、运算符 和 分隔符。空白符不是。</p>
<h2 id="2-3-标识符和关键字"><a href="#2-3-标识符和关键字" class="headerlink" title="2.3.标识符和关键字"></a>2.3.标识符和关键字</h2><p>标识符（Identifier）也叫做名字，就是平时所说的变量名一类，词法定义如下：</p>
<blockquote>
<p>identifier ::=  (letter|”<em>“) (letter | digit | “</em>“)*<br>  letter     ::=  lowercase | uppercase<br>  lowercase  ::=  “a”…”z”<br>  uppercase  ::=  “A”…”Z”<br>  digit      ::=  “0”…”9”</p>
</blockquote>
<p>标识符不限长度，大小写敏感，Python的标识符要求和其他语言基本一样。<br>另外，标识符命名推荐使用”_”分隔，而不是大小写的驼峰法，具体推荐命名法见PEP8。</p>
<h3 id="2-3-1-关键字"><a href="#2-3-1-关键字" class="headerlink" title="2.3.1.关键字"></a>2.3.1.关键字</h3><p>Python 2的关键字就这么多：</p>
<blockquote>
<p>and       del       from      not       while<br>  as        elif      global    or        with<br>  assert    else      if        pass      yield<br>  break     except    import    print<br>  class     exec      in        raise<br>  continue  finally   is        return<br>  def       for       lambda    try</p>
</blockquote>
<p>顺带附上Python 3.4的关键字：</p>
<blockquote>
<p>False      class      finally    is         return<br>  None       continue   for        lambda     try<br>  True       def        from       nonlocal   while<br>  and        del        global     not        with<br>  as         elif       if         or         yield<br>  assert     else       import     pass<br>  break      except     in         raise</p>
</blockquote>
<h3 id="2-3-2-保留的标识符类型"><a href="#2-3-2-保留的标识符类型" class="headerlink" title="2.3.2.保留的标识符类型"></a>2.3.2.保留的标识符类型</h3><p><code>_*</code>：不会在from module import &#42;时被导入<br><code>__*__</code>:系统保留的名字，所以自己写的时候就不用这种名字格式<br><code>__*</code>:类的私有名</p>
<h2 id="2-4-字面值"><a href="#2-4-字面值" class="headerlink" title="2.4.字面值"></a>2.4.字面值</h2><p>字面值是某些内置类型的常量值的表示法</p>
<h3 id="2-4-1-字符串字面值"><a href="#2-4-1-字符串字面值" class="headerlink" title="2.4.1.字符串字面值"></a>2.4.1.字符串字面值</h3><p>词法定义,见<a href="https://docs.python.org/2/reference/lexical_analysis.html#string-literals" target="_blank" rel="external">String literals</a>：</p>
<pre>
stringliteral   ::=  [stringprefix](shortstring | longstring)
stringprefix    ::=  "r" | "u" | "ur" | "R" | "U" | "UR" | "Ur" | "uR"
                     | "b" | "B" | "br" | "Br" | "bR" | "BR"
shortstring     ::=  "'" shortstringitem* "'" | '"' shortstringitem* '"'
longstring      ::=  "'''" longstringitem* "'''"
                     | '"""' longstringitem* '"""'
shortstringitem ::=  shortstringchar | escapeseq
longstringitem  ::=  longstringchar | escapeseq
shortstringchar ::=  <any source="" character="" except="" "\"="" or="" newline="" the="" quote="">
longstringchar  ::=  <any source="" character="" except="" "\"="">
escapeseq       ::=  "\" <any ascii="" character="">
</any></any></any></pre>

<p>前缀：<br>r:表示原始字符串（raw strings），即不对字符串里的\进行特殊处理<br>u：表示Unicode字符串<br>b：b在Python 中没用，它是用于告诉2to3的自动转换程序，这个字符串转换成3后应该是个字节字面值。</p>
<h3 id="2-4-2-字符串字面值的连接"><a href="#2-4-2-字符串字面值的连接" class="headerlink" title="2.4.2.字符串字面值的连接"></a>2.4.2.字符串字面值的连接</h3><p>简单来说，写在一起的字符串会自动连接到一起，如”hello” ‘world’会自动连接成”helloworld”</p>
<p>注意这个功能是在语法层次上定义的, 但却是在编译时实现的。 在运行时连接字符串表达式必须使用” +” 运算符。在字面值连接时, 不同的引用字符可以混用, 甚至原始串与三重引用串也可以混合使用.</p>
<h3 id="2-4-4数值型字面值"><a href="#2-4-4数值型字面值" class="headerlink" title="2.4.4数值型字面值"></a>2.4.4数值型字面值</h3><p>Python 2有四种字面值：普通整数（plain integers）、长整数（long integers）、浮点数（floating point numbers）、虚数（imaginary numbers）（Python 3中只有三种，只有整数）。复数用实数+虚数的形式表示。</p>
<p>词法定义：</p>
<pre>
longinteger    ::=  integer ("l" | "L")
integer        ::=  decimalinteger | octinteger | hexinteger | bininteger
decimalinteger ::=  nonzerodigit digit* | "0"
octinteger     ::=  "0" ("o" | "O") octdigit+ | "0" octdigit+
hexinteger     ::=  "0" ("x" | "X") hexdigit+
bininteger     ::=  "0" ("b" | "B") bindigit+
nonzerodigit   ::=  "1"..."9"
octdigit       ::=  "0"..."7"
bindigit       ::=  "0" | "1"
hexdigit       ::=  digit | "a"..."f" | "A"..."F"
</pre>

<p>要注意的是L要大写，来和数字1区分。Python 3对整数的统一更有好些，在Python 2中，数值溢出时候会自动转换成带L后缀的长整数。长整数的取值范围没有限制，由可用内存而定。</p>
<p>参考阅读：<a href="https://docs.python.org/2/library/sys.html#sys.maxint" target="_blank" rel="external">sys.maxint</a></p>
<h3 id="2-4-5-浮点型字面值"><a href="#2-4-5-浮点型字面值" class="headerlink" title="2.4.5.浮点型字面值"></a>2.4.5.浮点型字面值</h3><p>词法定义：</p>
<pre>
floatnumber   ::=  pointfloat | exponentfloat
pointfloat    ::=  [intpart] fraction | intpart "."
exponentfloat ::=  (intpart | pointfloat) exponent
intpart       ::=  digit+
fraction      ::=  "." digit+
exponent      ::=  ("e" | "E") ["+" | "-"] digit+
</pre>

<p>浮点数的取值范围依赖于实现。注意整数部分和指数部分都看作是十进制的. 例如, 077e010 是合法的, 它等价于 77e10,下面这些奇奇怪怪的形式也是可以的:<br>3.14    10.    .001    1e100    3.14e-10    0e0</p>
<p>浮点型的取值范围和机器有关，可以使用sys.float_info查看相关信息，会得到这样的结果：</p>
<blockquote>
<p>sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)</p>
</blockquote>
<p>参考阅读：<a href="https://docs.python.org/2/library/sys.html#sys.float_info" target="_blank" rel="external">sys.float_info</a></p>
<h3 id="2-4-6-虚数字面值"><a href="#2-4-6-虚数字面值" class="headerlink" title="2.4.6.虚数字面值"></a>2.4.6.虚数字面值</h3><p>词法定义：<br>imagnumber ::=  (floatnumber | intpart) (“j” | “J”)</p>
<p>虚数是实部为零的复数. 复数由一对有着相同取值范围的浮点数表示. 为了创建一个非零实部的复数, 可以对它增加一个浮点数, 例如, (3+4j). 下面是一些例子:<br>3.14j   10.j    10j     .001j   1e100j  3.14e-10j</p>
<h2 id="2-5-运算符"><a href="#2-5-运算符" class="headerlink" title="2.5.运算符"></a>2.5.运算符</h2><p>运算符包括：</p>
<pre>
+       -       *       **      /       //      %
<<      >     &       |       ^       ~
<             <=>=      ==      !=      <>
</=></pre>

<p>其中!=和&lt;&gt;是一个意思，不建议使用后者，并且它在Python 3中已经取消。</p>
<h2 id="2-6-分隔符"><a href="#2-6-分隔符" class="headerlink" title="2.6.分隔符"></a>2.6.分隔符</h2><p>分隔符包括：</p>
<pre>
(       )       [       ]       {       }
,       :       .       ;       @       =
+=      -=      *=      /=      //=     %=
&=      |=      ^=      >>=     <<= **="</pre"></=></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第二章-词法分析（Lexical-analysis）&quot;&gt;&lt;a href=&quot;#第二章-词法分析（Lexical-analysis）&quot; class=&quot;headerlink&quot; title=&quot;第二章 词法分析（Lexical analysis）&quot;&gt;&lt;/a&gt;第二章 词法分析
    
    </summary>
    
      <category term="编程笔记" scheme="http://ifchanged.io/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://ifchanged.io/tags/Python/"/>
    
      <category term="The Python Language Reference阅读笔记" scheme="http://ifchanged.io/tags/The-Python-Language-Reference%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>第1章 简介——The Python Language Reference阅读笔记</title>
    <link href="http://ifchanged.io/2015/%E7%AC%AC1%E7%AB%A0%20%E7%AE%80%E4%BB%8B%E2%80%94%E2%80%94The%20Python%20Language%20Reference%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://ifchanged.io/2015/第1章 简介——The Python Language Reference阅读笔记/</id>
    <published>2015-04-14T15:10:25.000Z</published>
    <updated>2017-01-08T14:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于阅读笔记"><a href="#关于阅读笔记" class="headerlink" title="关于阅读笔记"></a>关于阅读笔记</h1><p>《The Python 2 Language Reference阅读笔记》系列文章是我阅读Python 2的The Python Language Reference所记的笔记，不是翻译，也不会全部罗列Reference所讲的全部内容，而是记一些笔记和心得。</p>
<p>在笔记中有我对文档的一些理解，以及相关内容的资料，文档原文在<a href="https://docs.python.org/2/reference/index.html" target="_blank" rel="external">The Python Language Reference</a>，另有一份中文翻译<a href="http://python.usyiyi.cn/python_278/reference/index.html" target="_blank" rel="external">Python 语言参考</a>，没有完整阅读过翻译，翻译质量未知。</p>
<hr>
<h1 id="第一章-简介"><a href="#第一章-简介" class="headerlink" title="第一章 简介"></a>第一章 简介</h1><h2 id="1-1-可选实现"><a href="#1-1-可选实现" class="headerlink" title="1.1.可选实现"></a>1.1.可选实现</h2><p>常见的Python实现有CPython、Jython、Python for .NET、IronPython、Pypy。</p>
<p>Cpython是最流行的的实现，C编写，也是官方的实现。Jython是Java的实现。Python for .NET和IronPython都是.Net相关的实现。PyPy是用Python本身实现的Python，值得关注。</p>
<h2 id="1-2-记号法"><a href="#1-2-记号法" class="headerlink" title="1.2.记号法"></a>1.2.记号法</h2><p>Reference的词法和语法分析描述方法由巴克斯范式（BNF）修改而来，比较简单。</p>
<blockquote>
<p>name      ::=  lc_letter (lc<em>letter | “</em>“)*<br>  lc_letter ::=  “a”…”z”</p>
</blockquote>
<p>第一行是说name是一个lc_letter，后面跟着一个零个或多个lc_letter和下划线组成的序列。接着，一个lc_letter是’a’到’z’之间任意一个单个字符。（这个规则事实上就是该文档中词法和语法规则中的名称的定义方式。）</p>
<p>每条规则以一个名字（这条规则定义的名字）和::=开始。竖线(|)用于分隔可选的项；它是该语法符号中绑定性最弱的操作符。星号(&#42;)表示前面项目的零个或多个重复；类似地, 加号(+)表示一个或多个重复, 而方括号([ ])表示里面的内容出现零次或一次（换句话说, 方括号中的内容是可选的）。*和+操作符的绑定性最强；圆括号用于分组。字符串字面值由引号引起来。空格只对分隔标识符有意义。规则通常包含在单独的一行中；具有许多可选项的规则可能会在第一行之后，每一行以一个竖线开始。</p>
<p>在词法定义中（如上面的例子），还使用了两个额外的约定：三个点号分隔的两个字符表示给出的范围内（包括这两个字符）的任何一个单个ASCII字符。尖括号(&lt;…&gt;)中的内容表示不是定义的符号的正式描述；例如，如果需要这可以用来描述‘控制字符’的概念。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于阅读笔记&quot;&gt;&lt;a href=&quot;#关于阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;关于阅读笔记&quot;&gt;&lt;/a&gt;关于阅读笔记&lt;/h1&gt;&lt;p&gt;《The Python 2 Language Reference阅读笔记》系列文章是我阅读Python 2的
    
    </summary>
    
      <category term="编程笔记" scheme="http://ifchanged.io/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://ifchanged.io/tags/Python/"/>
    
      <category term="The Python Language Reference阅读笔记" scheme="http://ifchanged.io/tags/The-Python-Language-Reference%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>把wordpress迁移到子目录</title>
    <link href="http://ifchanged.io/2014/%E6%8A%8Awordpress%E8%BF%81%E7%A7%BB%E5%88%B0%E5%AD%90%E7%9B%AE%E5%BD%95/"/>
    <id>http://ifchanged.io/2014/把wordpress迁移到子目录/</id>
    <published>2014-12-12T15:56:13.000Z</published>
    <updated>2017-01-08T14:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前把wordpress安装在根目录，虽然这样建立wordpress很方便，但也会把根目录弄得很混乱，尤其是建立其他站点时很不方便，好在把wordpress迁移到子目录，并且<strong>不改变站点地址</strong>并不麻烦。</p>
<p>方法可以参考官方文档<a href="http://codex.wordpress.org/zh-cn:%E5%B0%86_WordPress_%E6%96%87%E4%BB%B6%E7%BD%AE%E4%BA%8E%E7%8B%AC%E7%AB%8B%E5%AD%90%E7%9B%AE%E5%BD%95" target="_blank" rel="external">将 WordPress 文件置于独立子目录</a>。</p>
<h2 id="迁移方法"><a href="#迁移方法" class="headerlink" title="迁移方法"></a>迁移方法</h2><ol>
<li>建立子目录，如wordpress</li>
<li>进入wordpress后台的<strong>设置</strong> - <strong>常规</strong>，设置index.php 和 .htaccess为新的地址，比如<a href="http://www.itoldme.net/wordpress，站点地址（URL）无需修改。" target="_blank" rel="external">http://www.itoldme.net/wordpress，站点地址（URL）无需修改。</a></li>
<li>把wordpress所有文件<strong>剪切</strong>到wordpress目录下</li>
<li>把index.php 和 .htaccess<strong>复制</strong>到根目录</li>
<li>编辑index.php，require(‘./wp-blog-header.php’); 修改为 require(‘./wordpress/wp-blog-header.php’); 其中的wordpress是你的子目录</li>
<li>此刻站点迁移完成，新的后台地址将会添加子目录，比如成为<a href="http://example.com/wordpress/wp-admin/" target="_blank" rel="external">http://example.com/wordpress/wp-admin/</a></li>
</ol>
<h2 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h2><ol>
<li><p>如果图片放置在wordpress中，由于wordpress采用绝对路径，所以新的图片路径也变了，会在wp-content前添加子目录名称，如www.itoldme.net/wordpress/wp-content/uploads/。则文章中引用的图片路径需要修改，方法是修改数据库。如果不会sql语句的话，可以使用插件<strong>Search &amp; Replace</strong>，把www.itoldme.net/wp-content/uploads/全部替换成www.itoldme.net/wordpress/wp-content/uploads/，如图<img src="http://www.itoldme.net/wordpress/wp-content/uploads/2014/12/20141212235031.png" alt="Search &amp; Replace示意图"></p>
</li>
<li><p>如果启用了WP Super Cache的CDN功能，需要在站点地址Off-site URL中添加子目录，如图<img src="http://www.itoldme.net/wordpress/wp-content/uploads/2014/12/20141213000651.png" alt="cdn设置示意图"></p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前把wordpress安装在根目录，虽然这样建立wordpress很方便，但也会把根目录弄得很混乱，尤其是建立其他站点时很不方便，好在把wordpress迁移到子目录，并且&lt;strong&gt;不改变站点地址&lt;/strong&gt;并不麻烦。&lt;/p&gt;
&lt;p&gt;方法可以参考官方文档&lt;a 
    
    </summary>
    
      <category term="网站建设" scheme="http://ifchanged.io/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"/>
    
    
      <category term="wordpress" scheme="http://ifchanged.io/tags/wordpress/"/>
    
  </entry>
  
  <entry>
    <title>你好，Linode</title>
    <link href="http://ifchanged.io/2014/%E4%BD%A0%E5%A5%BD%EF%BC%8CLinode/"/>
    <id>http://ifchanged.io/2014/你好，Linode/</id>
    <published>2014-12-01T14:39:46.000Z</published>
    <updated>2017-01-08T14:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>一直对Linode很向往，恰巧Linode黑色星期五优惠，新用户赠送25美元，就入手了，可惜忘了使用lindoe10的优惠码，10美元就擦肩而过了。本来打算和同学合租个VPS玩玩的，不过恰巧有此优惠就入手了，毕竟Linode价格不便宜。</p>
<h2 id="支付方式"><a href="#支付方式" class="headerlink" title="支付方式"></a>支付方式</h2><p>Linode不支持支付宝，不过要感谢腾讯财付通的虚拟运通卡，可以轻轻松松支付美元。进入财付通，点击“境外支付”就能找到相关功能。</p>
<h2 id="初体验"><a href="#初体验" class="headerlink" title="初体验"></a>初体验</h2><p>由于现在没有时间，所以暂未开通VPS，具体的使用体验要等到一个月后了。不过，也感受到了VPS优质的服务。</p>
<p>因为初次使用，所以误开通了一个最贵的VPS，本以为我的账户余额没这么多不会开通，结果原来Linode按照时间计算，所以立刻扣除了一小时的费用1.44美元。还好我立刻删除了这个VPS，不过也知道不要随便点，Linode提交订单前没有“确定”。然后立刻发了个ticket给客服，看样子我的英语还勉强可以，客服理解了我的意思，并很快退还了费用。</p>
<p>&nbsp;</p>
<h2 id="未来。。。"><a href="#未来。。。" class="headerlink" title="未来。。。"></a>未来。。。</h2><p>等考完就可以尽情折腾了，把之前写的网站都可以放在上面，然后折腾折腾linux，各种折腾折腾。一个月时间也很快，祝我好运~</p>
<p>等一个月后，再来续写这篇文章。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直对Linode很向往，恰巧Linode黑色星期五优惠，新用户赠送25美元，就入手了，可惜忘了使用lindoe10的优惠码，10美元就擦肩而过了。本来打算和同学合租个VPS玩玩的，不过恰巧有此优惠就入手了，毕竟Linode价格不便宜。&lt;/p&gt;
&lt;h2 id=&quot;支付方式&quot;&gt;
    
    </summary>
    
      <category term="About互联网" scheme="http://ifchanged.io/categories/About%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
    
      <category term="Linode" scheme="http://ifchanged.io/tags/Linode/"/>
    
      <category term="VPS" scheme="http://ifchanged.io/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>自动更新host的软件updateHosts</title>
    <link href="http://ifchanged.io/2014/%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0host%E7%9A%84%E8%BD%AF%E4%BB%B6updateHosts/"/>
    <id>http://ifchanged.io/2014/自动更新host的软件updateHosts/</id>
    <published>2014-10-26T14:27:02.000Z</published>
    <updated>2017-01-08T14:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="updateHosts"><a href="#updateHosts" class="headerlink" title="updateHosts"></a>updateHosts</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>自动从网络下载hosts文件，hosts源由用户设置。</p>
<h3 id="hosts是什么？"><a href="#hosts是什么？" class="headerlink" title="hosts是什么？"></a>hosts是什么？</h3><blockquote>
<p>hosts文件是一个用于储存计算机网络中各节点信息的计算机文件。这个文件负责将主机名映射到相应的IP地址。hosts文件通常用于补充或取代网络中DNS的功能。和DNS不同的是，计算机的用户可以直接对hosts文件进行控制。 ——<a href="http://zh.wikipedia.org/zh-cn/Hosts%E6%96%87%E4%BB%B6" title="hosts文件 - 维基百科，自由的百科全书" target="_blank" rel="external">hosts文件 - 维基百科，自由的百科全书</a></p>
</blockquote>
<h3 id="hosts的功能"><a href="#hosts的功能" class="headerlink" title="hosts的功能"></a>hosts的功能</h3><blockquote>
<p>hosts文件也可以用于其它情况，例如可以将已知的广告服务器重定向到无广告的机器（通常是本地的IP地址：127.0.0.1）上来过滤广告。同时也可以通过不下载网络广告，从而减少带宽。使用hosts文件还可以减少对DNS服务器的访问来加快访问速度并减少带宽消耗。</p>
<p>  hosts文件的另一个重要用途就是用于拦截一些恶意网站的请求，从而防止访问欺诈网站或感染一些病毒或恶意软件。但同时，这个文件也可能被病毒或恶意软件所利用来阻止用户更新杀毒软件或访问特定网站。</p>
<p>  在中国大陆，由于防火长城的DNS劫持，有一些网民也借使用hosts文件来强制将特定网站指定到未封锁的IP上。例如网络上有很多教授修改hosts文件来访问Google搜索的教程。比如就有维基媒体基金会的图片服务器IP地址被ISP封锁，通过修改hosts文件以正常显示图片的方法流传。  ——<a href="http://zh.wikipedia.org/zh-cn/Hosts%E6%96%87%E4%BB%B6" title="hosts文件 - 维基百科，自由的百科全书" target="_blank" rel="external">hosts文件 - 维基百科，自由的百科全书</a></p>
</blockquote>
<h3 id="updateHosts的功能"><a href="#updateHosts的功能" class="headerlink" title="updateHosts的功能"></a>updateHosts的功能</h3><p>updateHosts可以自动从网络下载最新的hosts文件，并自动替换系统的hosts文件。更多更能请见下文描述。</p>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>下载地址：<a href="https://github.com/ladder1984/updateHosts/archive/master.zip" target="_blank" rel="external">https://github.com/ladder1984/updateHosts/archive/master.zip</a> 解压即可使用。</p>
<h3 id="运行方法"><a href="#运行方法" class="headerlink" title="运行方法"></a>运行方法</h3><ul>
<li><strong>Windows用户</strong>：点击<strong>start.vbs</strong>运行，点击<strong>addToStartup.js</strong>加入启动项。无须安装Python。</li>
<li><strong>Linux/Mac OS用户</strong>：如未安装Python，请自行安装Python 2.x。点击<strong>updateHosts.py</strong>执行程序。</li>
</ul>
<h3 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h3><ul>
<li><strong>config.ini：</strong> 设置参数，包括选择更新源、开启关闭功能。详见config.ini中的注释<em>   <em>*hosts_user_defined.txt：</em></em> 可填入自定义hosts内容</li>
</ul>
<h3 id="设置说明"><a href="#设置说明" class="headerlink" title="设置说明"></a>设置说明</h3><p>目前可以在config.ini文件中方设置功能。0为不开启，1为开启此功能。目前可设置的功能有：</p>
<ul>
<li>not_block_sites 开启后，将注释掉通过127.0.0.1屏蔽的网址</li>
<li>always_on 开启后，将常驻内存，每小时执行一次更新</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>本软件不提供hosts文件，而是从从用户定义的地址下载hosts，默认提供几个流行的hosts，参见config.ini</li>
<li>建议使用前手动备份hosts文件</li>
<li>Windows用户可能需要授予程序管理员权限：右击python27.exe，选中“属性”，在“兼容性”里勾选“以管理员身份运行此程序”。</li>
<li>建议使用Notepad++、Sublime Text编辑文件</li>
<li>删除启动项（Windows用户）：删除“启动”文件夹内的快捷方式，“启动”文件夹在开始菜单内</li>
</ul>
<h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ul>
<li>操作系统：Windows、Linux、Mac OS</li>
</ul>
<h2 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h2><ul>
<li>下载hosts文件并更新本地hosts</li>
<li>用户可自定义hosts内容</li>
<li>可选的hosts更新源</li>
<li>可以选择下载多个hosts文件并合并</li>
<li>备份hosts文件</li>
<li>可去除屏蔽广告部分</li>
<li>可常驻后台，可每小时执行一次</li>
<li>分离出单独的配置文件</li>
<li>运行时不显示窗口</li>
<li>打包成exe文件，无需安装python即可使用</li>
<li>可单文件执行updateHosts</li>
<li>可添加启动项</li>
<li>生成错误日志errorLog.txt</li>
<li>待添加</li>
</ul>
<h2 id="hosts源"><a href="#hosts源" class="headerlink" title="hosts源"></a>hosts源</h2><p>hosts源来源于网络，收录入<a href="https://github.com/ladder1984/someHosts" target="_blank" rel="external">someHosts</a>项目，并选取如下hosts：</p>
<ul>
<li>simpleu-hosts <a href="https://github.com/vokins/simpleu" target="_blank" rel="external">https://github.com/vokins/simpleu</a></li>
<li>google-hosts <a href="https://github.com/txthinking/google-hosts" target="_blank" rel="external">https://github.com/txthinking/google-hosts</a></li>
<li>GavinHosts <a href="http://blog.crpuer.com/GavinHosts.txt" target="_blank" rel="external">http://blog.crpuer.com/GavinHosts.txt</a></li>
<li>General Hosts (ghosts) <a href="http://h.heartnn.eu.org/hosts" target="_blank" rel="external">http://h.heartnn.eu.org/hosts</a></li>
<li>imouto.host <a href="https://github.com/zxdrive/imouto.host" target="_blank" rel="external">https://github.com/zxdrive/imouto.host</a></li>
</ul>
<p>用户可在config.ini中选择，或者自定义hosts源。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>updateHosts项目地址：<a href="https://github.com/ladder1984/updateHosts" target="_blank" rel="external">https://github.com/ladder1984/updateHosts</a></li>
<li>ChangeLog：<a href="https://github.com/ladder1984/updateHosts/blob/master/ChangeLog.txt" target="_blank" rel="external">https://github.com/ladder1984/updateHosts/blob/master/ChangeLog.txt</a></li>
<li>作者：<a href="https://github.com/ladder1984" target="_blank" rel="external">https://github.com/ladder1984</a> 博客：<a href="http://www.itoldme.net" target="_blank" rel="external">http://www.itoldme.net</a></li>
<li>欢迎反馈问题和建议，地址：<a href="https://github.com/ladder1984/updateHosts/issues" target="_blank" rel="external">https://github.com/ladder1984/updateHosts/issues</a></li>
</ul>
<h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><ul>
<li>本软件使用MIT协议</li>
</ul>
<hr>
<p>本文不再更新，updateHosts目前情况，请访问项目主页：<a href="https://github.com/ladder1984/updateHosts" target="_blank" rel="external">https://github.com/ladder1984/updateHosts</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;updateHosts&quot;&gt;&lt;a href=&quot;#updateHosts&quot; class=&quot;headerlink&quot; title=&quot;updateHosts&quot;&gt;&lt;/a&gt;updateHosts&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;head
    
    </summary>
    
      <category term="编程笔记" scheme="http://ifchanged.io/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://ifchanged.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python用PyInstaller打包笔记</title>
    <link href="http://ifchanged.io/2014/Python%E7%94%A8PyInstaller%E6%89%93%E5%8C%85%E7%AC%94%E8%AE%B0/"/>
    <id>http://ifchanged.io/2014/Python用PyInstaller打包笔记/</id>
    <published>2014-10-22T13:37:11.000Z</published>
    <updated>2017-01-08T14:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了把python发行到没有安装python的Windows环境使用，需要打包成exe可执行文件。现在常见的python打包工具有cx_Freeze、PyInstaller和py2exe，想想我当初接触python的时候，似乎只有py2exe，而且有不少问题时光荏苒，一切过的真快。本文介绍PyInstaller打包的使用。</p>
<h2 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一.准备工作"></a>一.准备工作</h2><h3 id="安装PyWin32"><a href="#安装PyWin32" class="headerlink" title="安装PyWin32"></a>安装PyWin32</h3><p>到<a href="http://sourceforge.net/projects/pywin32/" target="_blank" rel="external">http://sourceforge.net/projects/pywin32/</a>下载 PyWin32，本文使用的是 pywin32-219.win-amd64-py2.7，地址：<a href="http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/pywin32-219.win-amd64-py2.7.exe/download" target="_blank" rel="external">http://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/pywin32-219.win-amd64-py2.7.exe/download</a></p>
<h3 id="下载PyInstaller"><a href="#下载PyInstaller" class="headerlink" title="下载PyInstaller"></a>下载PyInstaller</h3><p>到<a href="http://www.pyinstaller.org/" target="_blank" rel="external">http://www.pyinstaller.org/</a>下载PyInstaller并解压缩。本文使用PyInstaller 2.1。</p>
<p><strong>或者</strong>使用pip安装，执行<strong>pip install pyinstaller</strong></p>
<h3 id="下载upx（可选）"><a href="#下载upx（可选）" class="headerlink" title="下载upx（可选）"></a>下载upx（可选）</h3><p>到<a href="http://upx.sourceforge.net/" target="_blank" rel="external">http://upx.sourceforge.net/</a>下载upx，解压后把upx放在PyInstaller目录下，upx的作用是给生成的exe加壳，减小体积。</p>
<h2 id="二-使用方法"><a href="#二-使用方法" class="headerlink" title="二.使用方法"></a>二.使用方法</h2><p>cmd切换到PyInstaller文件夹，执行命令，如：</p>
<blockquote>
<p>pyinstaller myscript.py</p>
</blockquote>
<p>当然也可以添加输出选项，获得更好的exe可执行文件，如：</p>
<blockquote>
<p>python pyinstaller.py –upx-dir -F xxx.py</p>
</blockquote>
<p>-F用于制作独立的可执行程序，–upx-dir用于压缩文件。</p>
<p><strong>注意：</strong></p>
<ul>
<li>网上教程常见的-X选项启用upx已经失效</li>
<li>如果upx.exe已经复制到PyInstaller文件夹下，会默认使用upx，如果不在文件夹下，可以使用–upx-dir选项，如–upx-dir=upx_dir，如–upx-dir=/usr/local/share/</li>
<li>如果upx.exe复制到了PyInstaller文件夹下，如果不想使用upx，需要添加参数 –noupx</li>
</ul>
<h2 id="三-常用参数介绍"><a href="#三-常用参数介绍" class="headerlink" title="三.常用参数介绍"></a>三.常用参数介绍</h2><p>-F 用于制作独立的可执行程序</p>
<p>–upx-dir 使用upx加壳从而压缩exe文件</p>
<p>–noconsole适用于Windows和Mac OS X，用于创建不显示控制台窗口的程序</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>PyInstaller可以用于多个平台的打包，包括 Windows (32-bit and 64-bit),Linux (32-bit and 64-bit),Mac OS X (32-bit and 64-bit),experimentally Solaris and AIX。</p>
<p>PyInstaller也可以自定义ico文件等，完整使用手册参见<a href="http://pythonhosted.org/PyInstaller/" title="官方文档" target="_blank" rel="external">http://pythonhosted.org/PyInstaller/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了把python发行到没有安装python的Windows环境使用，需要打包成exe可执行文件。现在常见的python打包工具有cx_Freeze、PyInstaller和py2exe，想想我当初接触python的时候，似乎只有py2exe，而且有不少问题时光荏苒，一切过
    
    </summary>
    
      <category term="编程笔记" scheme="http://ifchanged.io/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Python" scheme="http://ifchanged.io/tags/Python/"/>
    
  </entry>
  
</feed>
